{"version":3,"file":"server.js","sources":["webpack:///webpack/bootstrap","webpack:///(webpack)/hot/log-apply-result.js","webpack:///(webpack)/hot/log.js","webpack:///(webpack)/hot/poll.js","webpack:///./src/LoadEnv.ts","webpack:///./src/api/ApiController.ts","webpack:///./src/api/Keychain.ts","webpack:///./src/api/PlaceController.ts","webpack:///./src/api/PlaceInfoController.ts","webpack:///./src/index.ts","webpack:///./src/routes/index.ts","webpack:///./src/utils/account-utils.js","webpack:///./src/utils/api-utils.js","webpack:///./src/utils/bitcoin-utils.js","webpack:///./src/utils/browser/store/settings/default.js","webpack:///./src/utils/encryption-utils.js","webpack:///./src/utils/index.js","webpack:///./src/utils/name-utils.js","webpack:///./src/utils/profile-utils.js","webpack:///./src/utils/profile.ts","webpack:///./src/utils/search-utils.js","webpack:///./src/utils/window-utils.js","webpack:///./src/utils/workers/crypto-check.worker.js","webpack:///./src/utils/workers/decrypt.main.js","webpack:///./src/utils/workers/decrypt.worker.js","webpack:///./src/utils/workers/encrypt.main.js","webpack:///./src/utils/workers/encrypt.worker.js","webpack:///./src/utils/zone-utils.js"],"sourcesContent":[" \t// eslint-disable-next-line no-unused-vars\n \tfunction hotDownloadUpdateChunk(chunkId) {\n \t\tvar chunk = require(\"./\" + \"\" + chunkId + \".\" + hotCurrentHash + \".hot-update.js\");\n \t\thotAddUpdateChunk(chunk.id, chunk.modules);\n \t}\n\n \t// eslint-disable-next-line no-unused-vars\n \tfunction hotDownloadManifest() {\n \t\ttry {\n \t\t\tvar update = require(\"./\" + \"\" + hotCurrentHash + \".hot-update.json\");\n \t\t} catch (e) {\n \t\t\treturn Promise.resolve();\n \t\t}\n \t\treturn Promise.resolve(update);\n \t}\n\n \t//eslint-disable-next-line no-unused-vars\n \tfunction hotDisposeChunk(chunkId) {\n \t\tdelete installedChunks[chunkId];\n \t}\n\n \tvar hotApplyOnUpdate = true;\n \t// eslint-disable-next-line no-unused-vars\n \tvar hotCurrentHash = \"35964b9096c08be6da41\";\n \tvar hotRequestTimeout = 10000;\n \tvar hotCurrentModuleData = {};\n \tvar hotCurrentChildModule;\n \t// eslint-disable-next-line no-unused-vars\n \tvar hotCurrentParents = [];\n \t// eslint-disable-next-line no-unused-vars\n \tvar hotCurrentParentsTemp = [];\n\n \t// eslint-disable-next-line no-unused-vars\n \tfunction hotCreateRequire(moduleId) {\n \t\tvar me = installedModules[moduleId];\n \t\tif (!me) return __webpack_require__;\n \t\tvar fn = function(request) {\n \t\t\tif (me.hot.active) {\n \t\t\t\tif (installedModules[request]) {\n \t\t\t\t\tif (installedModules[request].parents.indexOf(moduleId) === -1) {\n \t\t\t\t\t\tinstalledModules[request].parents.push(moduleId);\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\thotCurrentParents = [moduleId];\n \t\t\t\t\thotCurrentChildModule = request;\n \t\t\t\t}\n \t\t\t\tif (me.children.indexOf(request) === -1) {\n \t\t\t\t\tme.children.push(request);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tconsole.warn(\n \t\t\t\t\t\"[HMR] unexpected require(\" +\n \t\t\t\t\t\trequest +\n \t\t\t\t\t\t\") from disposed module \" +\n \t\t\t\t\t\tmoduleId\n \t\t\t\t);\n \t\t\t\thotCurrentParents = [];\n \t\t\t}\n \t\t\treturn __webpack_require__(request);\n \t\t};\n \t\tvar ObjectFactory = function ObjectFactory(name) {\n \t\t\treturn {\n \t\t\t\tconfigurable: true,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: function() {\n \t\t\t\t\treturn __webpack_require__[name];\n \t\t\t\t},\n \t\t\t\tset: function(value) {\n \t\t\t\t\t__webpack_require__[name] = value;\n \t\t\t\t}\n \t\t\t};\n \t\t};\n \t\tfor (var name in __webpack_require__) {\n \t\t\tif (\n \t\t\t\tObject.prototype.hasOwnProperty.call(__webpack_require__, name) &&\n \t\t\t\tname !== \"e\" &&\n \t\t\t\tname !== \"t\"\n \t\t\t) {\n \t\t\t\tObject.defineProperty(fn, name, ObjectFactory(name));\n \t\t\t}\n \t\t}\n \t\tfn.e = function(chunkId) {\n \t\t\tif (hotStatus === \"ready\") hotSetStatus(\"prepare\");\n \t\t\thotChunksLoading++;\n \t\t\treturn __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {\n \t\t\t\tfinishChunkLoading();\n \t\t\t\tthrow err;\n \t\t\t});\n\n \t\t\tfunction finishChunkLoading() {\n \t\t\t\thotChunksLoading--;\n \t\t\t\tif (hotStatus === \"prepare\") {\n \t\t\t\t\tif (!hotWaitingFilesMap[chunkId]) {\n \t\t\t\t\t\thotEnsureUpdateChunk(chunkId);\n \t\t\t\t\t}\n \t\t\t\t\tif (hotChunksLoading === 0 && hotWaitingFiles === 0) {\n \t\t\t\t\t\thotUpdateDownloaded();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t};\n \t\tfn.t = function(value, mode) {\n \t\t\tif (mode & 1) value = fn(value);\n \t\t\treturn __webpack_require__.t(value, mode & ~1);\n \t\t};\n \t\treturn fn;\n \t}\n\n \t// eslint-disable-next-line no-unused-vars\n \tfunction hotCreateModule(moduleId) {\n \t\tvar hot = {\n \t\t\t// private stuff\n \t\t\t_acceptedDependencies: {},\n \t\t\t_declinedDependencies: {},\n \t\t\t_selfAccepted: false,\n \t\t\t_selfDeclined: false,\n \t\t\t_disposeHandlers: [],\n \t\t\t_main: hotCurrentChildModule !== moduleId,\n\n \t\t\t// Module API\n \t\t\tactive: true,\n \t\t\taccept: function(dep, callback) {\n \t\t\t\tif (dep === undefined) hot._selfAccepted = true;\n \t\t\t\telse if (typeof dep === \"function\") hot._selfAccepted = dep;\n \t\t\t\telse if (typeof dep === \"object\")\n \t\t\t\t\tfor (var i = 0; i < dep.length; i++)\n \t\t\t\t\t\thot._acceptedDependencies[dep[i]] = callback || function() {};\n \t\t\t\telse hot._acceptedDependencies[dep] = callback || function() {};\n \t\t\t},\n \t\t\tdecline: function(dep) {\n \t\t\t\tif (dep === undefined) hot._selfDeclined = true;\n \t\t\t\telse if (typeof dep === \"object\")\n \t\t\t\t\tfor (var i = 0; i < dep.length; i++)\n \t\t\t\t\t\thot._declinedDependencies[dep[i]] = true;\n \t\t\t\telse hot._declinedDependencies[dep] = true;\n \t\t\t},\n \t\t\tdispose: function(callback) {\n \t\t\t\thot._disposeHandlers.push(callback);\n \t\t\t},\n \t\t\taddDisposeHandler: function(callback) {\n \t\t\t\thot._disposeHandlers.push(callback);\n \t\t\t},\n \t\t\tremoveDisposeHandler: function(callback) {\n \t\t\t\tvar idx = hot._disposeHandlers.indexOf(callback);\n \t\t\t\tif (idx >= 0) hot._disposeHandlers.splice(idx, 1);\n \t\t\t},\n\n \t\t\t// Management API\n \t\t\tcheck: hotCheck,\n \t\t\tapply: hotApply,\n \t\t\tstatus: function(l) {\n \t\t\t\tif (!l) return hotStatus;\n \t\t\t\thotStatusHandlers.push(l);\n \t\t\t},\n \t\t\taddStatusHandler: function(l) {\n \t\t\t\thotStatusHandlers.push(l);\n \t\t\t},\n \t\t\tremoveStatusHandler: function(l) {\n \t\t\t\tvar idx = hotStatusHandlers.indexOf(l);\n \t\t\t\tif (idx >= 0) hotStatusHandlers.splice(idx, 1);\n \t\t\t},\n\n \t\t\t//inherit from previous dispose call\n \t\t\tdata: hotCurrentModuleData[moduleId]\n \t\t};\n \t\thotCurrentChildModule = undefined;\n \t\treturn hot;\n \t}\n\n \tvar hotStatusHandlers = [];\n \tvar hotStatus = \"idle\";\n\n \tfunction hotSetStatus(newStatus) {\n \t\thotStatus = newStatus;\n \t\tfor (var i = 0; i < hotStatusHandlers.length; i++)\n \t\t\thotStatusHandlers[i].call(null, newStatus);\n \t}\n\n \t// while downloading\n \tvar hotWaitingFiles = 0;\n \tvar hotChunksLoading = 0;\n \tvar hotWaitingFilesMap = {};\n \tvar hotRequestedFilesMap = {};\n \tvar hotAvailableFilesMap = {};\n \tvar hotDeferred;\n\n \t// The update info\n \tvar hotUpdate, hotUpdateNewHash;\n\n \tfunction toModuleId(id) {\n \t\tvar isNumber = +id + \"\" === id;\n \t\treturn isNumber ? +id : id;\n \t}\n\n \tfunction hotCheck(apply) {\n \t\tif (hotStatus !== \"idle\") {\n \t\t\tthrow new Error(\"check() is only allowed in idle status\");\n \t\t}\n \t\thotApplyOnUpdate = apply;\n \t\thotSetStatus(\"check\");\n \t\treturn hotDownloadManifest(hotRequestTimeout).then(function(update) {\n \t\t\tif (!update) {\n \t\t\t\thotSetStatus(\"idle\");\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\thotRequestedFilesMap = {};\n \t\t\thotWaitingFilesMap = {};\n \t\t\thotAvailableFilesMap = update.c;\n \t\t\thotUpdateNewHash = update.h;\n\n \t\t\thotSetStatus(\"prepare\");\n \t\t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\t\thotDeferred = {\n \t\t\t\t\tresolve: resolve,\n \t\t\t\t\treject: reject\n \t\t\t\t};\n \t\t\t});\n \t\t\thotUpdate = {};\n \t\t\tvar chunkId = \"main\";\n \t\t\t// eslint-disable-next-line no-lone-blocks\n \t\t\t{\n \t\t\t\t/*globals chunkId */\n \t\t\t\thotEnsureUpdateChunk(chunkId);\n \t\t\t}\n \t\t\tif (\n \t\t\t\thotStatus === \"prepare\" &&\n \t\t\t\thotChunksLoading === 0 &&\n \t\t\t\thotWaitingFiles === 0\n \t\t\t) {\n \t\t\t\thotUpdateDownloaded();\n \t\t\t}\n \t\t\treturn promise;\n \t\t});\n \t}\n\n \t// eslint-disable-next-line no-unused-vars\n \tfunction hotAddUpdateChunk(chunkId, moreModules) {\n \t\tif (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])\n \t\t\treturn;\n \t\thotRequestedFilesMap[chunkId] = false;\n \t\tfor (var moduleId in moreModules) {\n \t\t\tif (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\thotUpdate[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif (--hotWaitingFiles === 0 && hotChunksLoading === 0) {\n \t\t\thotUpdateDownloaded();\n \t\t}\n \t}\n\n \tfunction hotEnsureUpdateChunk(chunkId) {\n \t\tif (!hotAvailableFilesMap[chunkId]) {\n \t\t\thotWaitingFilesMap[chunkId] = true;\n \t\t} else {\n \t\t\thotRequestedFilesMap[chunkId] = true;\n \t\t\thotWaitingFiles++;\n \t\t\thotDownloadUpdateChunk(chunkId);\n \t\t}\n \t}\n\n \tfunction hotUpdateDownloaded() {\n \t\thotSetStatus(\"ready\");\n \t\tvar deferred = hotDeferred;\n \t\thotDeferred = null;\n \t\tif (!deferred) return;\n \t\tif (hotApplyOnUpdate) {\n \t\t\t// Wrap deferred object in Promise to mark it as a well-handled Promise to\n \t\t\t// avoid triggering uncaught exception warning in Chrome.\n \t\t\t// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666\n \t\t\tPromise.resolve()\n \t\t\t\t.then(function() {\n \t\t\t\t\treturn hotApply(hotApplyOnUpdate);\n \t\t\t\t})\n \t\t\t\t.then(\n \t\t\t\t\tfunction(result) {\n \t\t\t\t\t\tdeferred.resolve(result);\n \t\t\t\t\t},\n \t\t\t\t\tfunction(err) {\n \t\t\t\t\t\tdeferred.reject(err);\n \t\t\t\t\t}\n \t\t\t\t);\n \t\t} else {\n \t\t\tvar outdatedModules = [];\n \t\t\tfor (var id in hotUpdate) {\n \t\t\t\tif (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\n \t\t\t\t\toutdatedModules.push(toModuleId(id));\n \t\t\t\t}\n \t\t\t}\n \t\t\tdeferred.resolve(outdatedModules);\n \t\t}\n \t}\n\n \tfunction hotApply(options) {\n \t\tif (hotStatus !== \"ready\")\n \t\t\tthrow new Error(\"apply() is only allowed in ready status\");\n \t\toptions = options || {};\n\n \t\tvar cb;\n \t\tvar i;\n \t\tvar j;\n \t\tvar module;\n \t\tvar moduleId;\n\n \t\tfunction getAffectedStuff(updateModuleId) {\n \t\t\tvar outdatedModules = [updateModuleId];\n \t\t\tvar outdatedDependencies = {};\n\n \t\t\tvar queue = outdatedModules.map(function(id) {\n \t\t\t\treturn {\n \t\t\t\t\tchain: [id],\n \t\t\t\t\tid: id\n \t\t\t\t};\n \t\t\t});\n \t\t\twhile (queue.length > 0) {\n \t\t\t\tvar queueItem = queue.pop();\n \t\t\t\tvar moduleId = queueItem.id;\n \t\t\t\tvar chain = queueItem.chain;\n \t\t\t\tmodule = installedModules[moduleId];\n \t\t\t\tif (!module || module.hot._selfAccepted) continue;\n \t\t\t\tif (module.hot._selfDeclined) {\n \t\t\t\t\treturn {\n \t\t\t\t\t\ttype: \"self-declined\",\n \t\t\t\t\t\tchain: chain,\n \t\t\t\t\t\tmoduleId: moduleId\n \t\t\t\t\t};\n \t\t\t\t}\n \t\t\t\tif (module.hot._main) {\n \t\t\t\t\treturn {\n \t\t\t\t\t\ttype: \"unaccepted\",\n \t\t\t\t\t\tchain: chain,\n \t\t\t\t\t\tmoduleId: moduleId\n \t\t\t\t\t};\n \t\t\t\t}\n \t\t\t\tfor (var i = 0; i < module.parents.length; i++) {\n \t\t\t\t\tvar parentId = module.parents[i];\n \t\t\t\t\tvar parent = installedModules[parentId];\n \t\t\t\t\tif (!parent) continue;\n \t\t\t\t\tif (parent.hot._declinedDependencies[moduleId]) {\n \t\t\t\t\t\treturn {\n \t\t\t\t\t\t\ttype: \"declined\",\n \t\t\t\t\t\t\tchain: chain.concat([parentId]),\n \t\t\t\t\t\t\tmoduleId: moduleId,\n \t\t\t\t\t\t\tparentId: parentId\n \t\t\t\t\t\t};\n \t\t\t\t\t}\n \t\t\t\t\tif (outdatedModules.indexOf(parentId) !== -1) continue;\n \t\t\t\t\tif (parent.hot._acceptedDependencies[moduleId]) {\n \t\t\t\t\t\tif (!outdatedDependencies[parentId])\n \t\t\t\t\t\t\toutdatedDependencies[parentId] = [];\n \t\t\t\t\t\taddAllToSet(outdatedDependencies[parentId], [moduleId]);\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \t\t\t\t\tdelete outdatedDependencies[parentId];\n \t\t\t\t\toutdatedModules.push(parentId);\n \t\t\t\t\tqueue.push({\n \t\t\t\t\t\tchain: chain.concat([parentId]),\n \t\t\t\t\t\tid: parentId\n \t\t\t\t\t});\n \t\t\t\t}\n \t\t\t}\n\n \t\t\treturn {\n \t\t\t\ttype: \"accepted\",\n \t\t\t\tmoduleId: updateModuleId,\n \t\t\t\toutdatedModules: outdatedModules,\n \t\t\t\toutdatedDependencies: outdatedDependencies\n \t\t\t};\n \t\t}\n\n \t\tfunction addAllToSet(a, b) {\n \t\t\tfor (var i = 0; i < b.length; i++) {\n \t\t\t\tvar item = b[i];\n \t\t\t\tif (a.indexOf(item) === -1) a.push(item);\n \t\t\t}\n \t\t}\n\n \t\t// at begin all updates modules are outdated\n \t\t// the \"outdated\" status can propagate to parents if they don't accept the children\n \t\tvar outdatedDependencies = {};\n \t\tvar outdatedModules = [];\n \t\tvar appliedUpdate = {};\n\n \t\tvar warnUnexpectedRequire = function warnUnexpectedRequire() {\n \t\t\tconsole.warn(\n \t\t\t\t\"[HMR] unexpected require(\" + result.moduleId + \") to disposed module\"\n \t\t\t);\n \t\t};\n\n \t\tfor (var id in hotUpdate) {\n \t\t\tif (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\n \t\t\t\tmoduleId = toModuleId(id);\n \t\t\t\t/** @type {TODO} */\n \t\t\t\tvar result;\n \t\t\t\tif (hotUpdate[id]) {\n \t\t\t\t\tresult = getAffectedStuff(moduleId);\n \t\t\t\t} else {\n \t\t\t\t\tresult = {\n \t\t\t\t\t\ttype: \"disposed\",\n \t\t\t\t\t\tmoduleId: id\n \t\t\t\t\t};\n \t\t\t\t}\n \t\t\t\t/** @type {Error|false} */\n \t\t\t\tvar abortError = false;\n \t\t\t\tvar doApply = false;\n \t\t\t\tvar doDispose = false;\n \t\t\t\tvar chainInfo = \"\";\n \t\t\t\tif (result.chain) {\n \t\t\t\t\tchainInfo = \"\\nUpdate propagation: \" + result.chain.join(\" -> \");\n \t\t\t\t}\n \t\t\t\tswitch (result.type) {\n \t\t\t\t\tcase \"self-declined\":\n \t\t\t\t\t\tif (options.onDeclined) options.onDeclined(result);\n \t\t\t\t\t\tif (!options.ignoreDeclined)\n \t\t\t\t\t\t\tabortError = new Error(\n \t\t\t\t\t\t\t\t\"Aborted because of self decline: \" +\n \t\t\t\t\t\t\t\t\tresult.moduleId +\n \t\t\t\t\t\t\t\t\tchainInfo\n \t\t\t\t\t\t\t);\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase \"declined\":\n \t\t\t\t\t\tif (options.onDeclined) options.onDeclined(result);\n \t\t\t\t\t\tif (!options.ignoreDeclined)\n \t\t\t\t\t\t\tabortError = new Error(\n \t\t\t\t\t\t\t\t\"Aborted because of declined dependency: \" +\n \t\t\t\t\t\t\t\t\tresult.moduleId +\n \t\t\t\t\t\t\t\t\t\" in \" +\n \t\t\t\t\t\t\t\t\tresult.parentId +\n \t\t\t\t\t\t\t\t\tchainInfo\n \t\t\t\t\t\t\t);\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase \"unaccepted\":\n \t\t\t\t\t\tif (options.onUnaccepted) options.onUnaccepted(result);\n \t\t\t\t\t\tif (!options.ignoreUnaccepted)\n \t\t\t\t\t\t\tabortError = new Error(\n \t\t\t\t\t\t\t\t\"Aborted because \" + moduleId + \" is not accepted\" + chainInfo\n \t\t\t\t\t\t\t);\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase \"accepted\":\n \t\t\t\t\t\tif (options.onAccepted) options.onAccepted(result);\n \t\t\t\t\t\tdoApply = true;\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase \"disposed\":\n \t\t\t\t\t\tif (options.onDisposed) options.onDisposed(result);\n \t\t\t\t\t\tdoDispose = true;\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new Error(\"Unexception type \" + result.type);\n \t\t\t\t}\n \t\t\t\tif (abortError) {\n \t\t\t\t\thotSetStatus(\"abort\");\n \t\t\t\t\treturn Promise.reject(abortError);\n \t\t\t\t}\n \t\t\t\tif (doApply) {\n \t\t\t\t\tappliedUpdate[moduleId] = hotUpdate[moduleId];\n \t\t\t\t\taddAllToSet(outdatedModules, result.outdatedModules);\n \t\t\t\t\tfor (moduleId in result.outdatedDependencies) {\n \t\t\t\t\t\tif (\n \t\t\t\t\t\t\tObject.prototype.hasOwnProperty.call(\n \t\t\t\t\t\t\t\tresult.outdatedDependencies,\n \t\t\t\t\t\t\t\tmoduleId\n \t\t\t\t\t\t\t)\n \t\t\t\t\t\t) {\n \t\t\t\t\t\t\tif (!outdatedDependencies[moduleId])\n \t\t\t\t\t\t\t\toutdatedDependencies[moduleId] = [];\n \t\t\t\t\t\t\taddAllToSet(\n \t\t\t\t\t\t\t\toutdatedDependencies[moduleId],\n \t\t\t\t\t\t\t\tresult.outdatedDependencies[moduleId]\n \t\t\t\t\t\t\t);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif (doDispose) {\n \t\t\t\t\taddAllToSet(outdatedModules, [result.moduleId]);\n \t\t\t\t\tappliedUpdate[moduleId] = warnUnexpectedRequire;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\t// Store self accepted outdated modules to require them later by the module system\n \t\tvar outdatedSelfAcceptedModules = [];\n \t\tfor (i = 0; i < outdatedModules.length; i++) {\n \t\t\tmoduleId = outdatedModules[i];\n \t\t\tif (\n \t\t\t\tinstalledModules[moduleId] &&\n \t\t\t\tinstalledModules[moduleId].hot._selfAccepted &&\n \t\t\t\t// removed self-accepted modules should not be required\n \t\t\t\tappliedUpdate[moduleId] !== warnUnexpectedRequire\n \t\t\t) {\n \t\t\t\toutdatedSelfAcceptedModules.push({\n \t\t\t\t\tmodule: moduleId,\n \t\t\t\t\terrorHandler: installedModules[moduleId].hot._selfAccepted\n \t\t\t\t});\n \t\t\t}\n \t\t}\n\n \t\t// Now in \"dispose\" phase\n \t\thotSetStatus(\"dispose\");\n \t\tObject.keys(hotAvailableFilesMap).forEach(function(chunkId) {\n \t\t\tif (hotAvailableFilesMap[chunkId] === false) {\n \t\t\t\thotDisposeChunk(chunkId);\n \t\t\t}\n \t\t});\n\n \t\tvar idx;\n \t\tvar queue = outdatedModules.slice();\n \t\twhile (queue.length > 0) {\n \t\t\tmoduleId = queue.pop();\n \t\t\tmodule = installedModules[moduleId];\n \t\t\tif (!module) continue;\n\n \t\t\tvar data = {};\n\n \t\t\t// Call dispose handlers\n \t\t\tvar disposeHandlers = module.hot._disposeHandlers;\n \t\t\tfor (j = 0; j < disposeHandlers.length; j++) {\n \t\t\t\tcb = disposeHandlers[j];\n \t\t\t\tcb(data);\n \t\t\t}\n \t\t\thotCurrentModuleData[moduleId] = data;\n\n \t\t\t// disable module (this disables requires from this module)\n \t\t\tmodule.hot.active = false;\n\n \t\t\t// remove module from cache\n \t\t\tdelete installedModules[moduleId];\n\n \t\t\t// when disposing there is no need to call dispose handler\n \t\t\tdelete outdatedDependencies[moduleId];\n\n \t\t\t// remove \"parents\" references from all children\n \t\t\tfor (j = 0; j < module.children.length; j++) {\n \t\t\t\tvar child = installedModules[module.children[j]];\n \t\t\t\tif (!child) continue;\n \t\t\t\tidx = child.parents.indexOf(moduleId);\n \t\t\t\tif (idx >= 0) {\n \t\t\t\t\tchild.parents.splice(idx, 1);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\t// remove outdated dependency from module children\n \t\tvar dependency;\n \t\tvar moduleOutdatedDependencies;\n \t\tfor (moduleId in outdatedDependencies) {\n \t\t\tif (\n \t\t\t\tObject.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)\n \t\t\t) {\n \t\t\t\tmodule = installedModules[moduleId];\n \t\t\t\tif (module) {\n \t\t\t\t\tmoduleOutdatedDependencies = outdatedDependencies[moduleId];\n \t\t\t\t\tfor (j = 0; j < moduleOutdatedDependencies.length; j++) {\n \t\t\t\t\t\tdependency = moduleOutdatedDependencies[j];\n \t\t\t\t\t\tidx = module.children.indexOf(dependency);\n \t\t\t\t\t\tif (idx >= 0) module.children.splice(idx, 1);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\t// Now in \"apply\" phase\n \t\thotSetStatus(\"apply\");\n\n \t\thotCurrentHash = hotUpdateNewHash;\n\n \t\t// insert new code\n \t\tfor (moduleId in appliedUpdate) {\n \t\t\tif (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {\n \t\t\t\tmodules[moduleId] = appliedUpdate[moduleId];\n \t\t\t}\n \t\t}\n\n \t\t// call accept handlers\n \t\tvar error = null;\n \t\tfor (moduleId in outdatedDependencies) {\n \t\t\tif (\n \t\t\t\tObject.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)\n \t\t\t) {\n \t\t\t\tmodule = installedModules[moduleId];\n \t\t\t\tif (module) {\n \t\t\t\t\tmoduleOutdatedDependencies = outdatedDependencies[moduleId];\n \t\t\t\t\tvar callbacks = [];\n \t\t\t\t\tfor (i = 0; i < moduleOutdatedDependencies.length; i++) {\n \t\t\t\t\t\tdependency = moduleOutdatedDependencies[i];\n \t\t\t\t\t\tcb = module.hot._acceptedDependencies[dependency];\n \t\t\t\t\t\tif (cb) {\n \t\t\t\t\t\t\tif (callbacks.indexOf(cb) !== -1) continue;\n \t\t\t\t\t\t\tcallbacks.push(cb);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tfor (i = 0; i < callbacks.length; i++) {\n \t\t\t\t\t\tcb = callbacks[i];\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tcb(moduleOutdatedDependencies);\n \t\t\t\t\t\t} catch (err) {\n \t\t\t\t\t\t\tif (options.onErrored) {\n \t\t\t\t\t\t\t\toptions.onErrored({\n \t\t\t\t\t\t\t\t\ttype: \"accept-errored\",\n \t\t\t\t\t\t\t\t\tmoduleId: moduleId,\n \t\t\t\t\t\t\t\t\tdependencyId: moduleOutdatedDependencies[i],\n \t\t\t\t\t\t\t\t\terror: err\n \t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (!options.ignoreErrored) {\n \t\t\t\t\t\t\t\tif (!error) error = err;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\t// Load self accepted modules\n \t\tfor (i = 0; i < outdatedSelfAcceptedModules.length; i++) {\n \t\t\tvar item = outdatedSelfAcceptedModules[i];\n \t\t\tmoduleId = item.module;\n \t\t\thotCurrentParents = [moduleId];\n \t\t\ttry {\n \t\t\t\t__webpack_require__(moduleId);\n \t\t\t} catch (err) {\n \t\t\t\tif (typeof item.errorHandler === \"function\") {\n \t\t\t\t\ttry {\n \t\t\t\t\t\titem.errorHandler(err);\n \t\t\t\t\t} catch (err2) {\n \t\t\t\t\t\tif (options.onErrored) {\n \t\t\t\t\t\t\toptions.onErrored({\n \t\t\t\t\t\t\t\ttype: \"self-accept-error-handler-errored\",\n \t\t\t\t\t\t\t\tmoduleId: moduleId,\n \t\t\t\t\t\t\t\terror: err2,\n \t\t\t\t\t\t\t\toriginalError: err\n \t\t\t\t\t\t\t});\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (!options.ignoreErrored) {\n \t\t\t\t\t\t\tif (!error) error = err2;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (!error) error = err;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tif (options.onErrored) {\n \t\t\t\t\t\toptions.onErrored({\n \t\t\t\t\t\t\ttype: \"self-accept-errored\",\n \t\t\t\t\t\t\tmoduleId: moduleId,\n \t\t\t\t\t\t\terror: err\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\tif (!options.ignoreErrored) {\n \t\t\t\t\t\tif (!error) error = err;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\t// handle errors in accept handlers and self accepted module load\n \t\tif (error) {\n \t\t\thotSetStatus(\"fail\");\n \t\t\treturn Promise.reject(error);\n \t\t}\n\n \t\thotSetStatus(\"idle\");\n \t\treturn new Promise(function(resolve) {\n \t\t\tresolve(outdatedModules);\n \t\t});\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {},\n \t\t\thot: hotCreateModule(moduleId),\n \t\t\tparents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),\n \t\t\tchildren: []\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// __webpack_hash__\n \t__webpack_require__.h = function() { return hotCurrentHash; };\n\n\n \t// Load entry module and return exports\n \treturn hotCreateRequire(0)(__webpack_require__.s = 0);\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nmodule.exports = function(updatedModules, renewedModules) {\n\tvar unacceptedModules = updatedModules.filter(function(moduleId) {\n\t\treturn renewedModules && renewedModules.indexOf(moduleId) < 0;\n\t});\n\tvar log = require(\"./log\");\n\n\tif (unacceptedModules.length > 0) {\n\t\tlog(\n\t\t\t\"warning\",\n\t\t\t\"[HMR] The following modules couldn't be hot updated: (They would need a full reload!)\"\n\t\t);\n\t\tunacceptedModules.forEach(function(moduleId) {\n\t\t\tlog(\"warning\", \"[HMR]  - \" + moduleId);\n\t\t});\n\t}\n\n\tif (!renewedModules || renewedModules.length === 0) {\n\t\tlog(\"info\", \"[HMR] Nothing hot updated.\");\n\t} else {\n\t\tlog(\"info\", \"[HMR] Updated modules:\");\n\t\trenewedModules.forEach(function(moduleId) {\n\t\t\tif (typeof moduleId === \"string\" && moduleId.indexOf(\"!\") !== -1) {\n\t\t\t\tvar parts = moduleId.split(\"!\");\n\t\t\t\tlog.groupCollapsed(\"info\", \"[HMR]  - \" + parts.pop());\n\t\t\t\tlog(\"info\", \"[HMR]  - \" + moduleId);\n\t\t\t\tlog.groupEnd(\"info\");\n\t\t\t} else {\n\t\t\t\tlog(\"info\", \"[HMR]  - \" + moduleId);\n\t\t\t}\n\t\t});\n\t\tvar numberIds = renewedModules.every(function(moduleId) {\n\t\t\treturn typeof moduleId === \"number\";\n\t\t});\n\t\tif (numberIds)\n\t\t\tlog(\n\t\t\t\t\"info\",\n\t\t\t\t\"[HMR] Consider using the NamedModulesPlugin for module names.\"\n\t\t\t);\n\t}\n};\n","var logLevel = \"info\";\n\nfunction dummy() {}\n\nfunction shouldLog(level) {\n\tvar shouldLog =\n\t\t(logLevel === \"info\" && level === \"info\") ||\n\t\t([\"info\", \"warning\"].indexOf(logLevel) >= 0 && level === \"warning\") ||\n\t\t([\"info\", \"warning\", \"error\"].indexOf(logLevel) >= 0 && level === \"error\");\n\treturn shouldLog;\n}\n\nfunction logGroup(logFn) {\n\treturn function(level, msg) {\n\t\tif (shouldLog(level)) {\n\t\t\tlogFn(msg);\n\t\t}\n\t};\n}\n\nmodule.exports = function(level, msg) {\n\tif (shouldLog(level)) {\n\t\tif (level === \"info\") {\n\t\t\tconsole.log(msg);\n\t\t} else if (level === \"warning\") {\n\t\t\tconsole.warn(msg);\n\t\t} else if (level === \"error\") {\n\t\t\tconsole.error(msg);\n\t\t}\n\t}\n};\n\n/* eslint-disable node/no-unsupported-features/node-builtins */\nvar group = console.group || dummy;\nvar groupCollapsed = console.groupCollapsed || dummy;\nvar groupEnd = console.groupEnd || dummy;\n/* eslint-enable node/no-unsupported-features/node-builtins */\n\nmodule.exports.group = logGroup(group);\n\nmodule.exports.groupCollapsed = logGroup(groupCollapsed);\n\nmodule.exports.groupEnd = logGroup(groupEnd);\n\nmodule.exports.setLogLevel = function(level) {\n\tlogLevel = level;\n};\n\nmodule.exports.formatError = function(err) {\n\tvar message = err.message;\n\tvar stack = err.stack;\n\tif (!stack) {\n\t\treturn message;\n\t} else if (stack.indexOf(message) < 0) {\n\t\treturn message + \"\\n\" + stack;\n\t} else {\n\t\treturn stack;\n\t}\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n/*globals __resourceQuery */\nif (module.hot) {\n\tvar hotPollInterval = +__resourceQuery.substr(1) || 10 * 60 * 1000;\n\tvar log = require(\"./log\");\n\n\tvar checkForUpdate = function checkForUpdate(fromUpdate) {\n\t\tif (module.hot.status() === \"idle\") {\n\t\t\tmodule.hot\n\t\t\t\t.check(true)\n\t\t\t\t.then(function(updatedModules) {\n\t\t\t\t\tif (!updatedModules) {\n\t\t\t\t\t\tif (fromUpdate) log(\"info\", \"[HMR] Update applied.\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\trequire(\"./log-apply-result\")(updatedModules, updatedModules);\n\t\t\t\t\tcheckForUpdate(true);\n\t\t\t\t})\n\t\t\t\t.catch(function(err) {\n\t\t\t\t\tvar status = module.hot.status();\n\t\t\t\t\tif ([\"abort\", \"fail\"].indexOf(status) >= 0) {\n\t\t\t\t\t\tlog(\"warning\", \"[HMR] Cannot apply update.\");\n\t\t\t\t\t\tlog(\"warning\", \"[HMR] \" + log.formatError(err));\n\t\t\t\t\t\tlog(\"warning\", \"[HMR] You need to restart the application!\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog(\"warning\", \"[HMR] Update failed: \" + log.formatError(err));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t};\n\tsetInterval(checkForUpdate, hotPollInterval);\n} else {\n\tthrow new Error(\"[HMR] Hot Module Replacement is disabled.\");\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst dotenv_1 = tslib_1.__importDefault(require(\"dotenv\"));\nconst command_line_args_1 = tslib_1.__importDefault(require(\"command-line-args\"));\nconst options = command_line_args_1.default([\n    {\n        name: 'env',\n        alias: 'e',\n        defaultValue: 'production',\n        type: String,\n    },\n]);\nconst result2 = dotenv_1.default.config({\n    path: `./env/${options.env}.env`,\n});\nif (result2.error) {\n    throw result2.error;\n}\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst express = require('express');\nconst { decorateApp } = require('@awaitjs/express');\nconst { COLLECTION } = require('radiks-server/app/lib/constants');\nconst makeApiController = (db) => {\n    const Router = decorateApp(express.Router());\n    const radiksData = db.collection(COLLECTION);\n    Router.getAsync('/messages', (req, res) => __awaiter(void 0, void 0, void 0, function* () {\n        const match = {\n            $match: {\n                radiksType: 'Message',\n            },\n        };\n        if (req.query.lt) {\n            match.$match.createdAt = {\n                $lt: parseInt(req.query.lt, 10),\n            };\n        }\n        if (req.query.createdBy) {\n            match.$match.createdBy = req.query.createdBy;\n        }\n        const sort = {\n            $sort: { createdAt: -1 },\n        };\n        const limit = {\n            $limit: 10,\n        };\n        const votesLookup = {\n            $lookup: {\n                from: COLLECTION,\n                localField: '_id',\n                foreignField: 'messageId',\n                as: 'votes',\n            },\n        };\n        const pipeline = [match, sort, limit, votesLookup];\n        const messages = yield radiksData.aggregate(pipeline).toArray();\n        let username = (req.query.fetcher || req.universalCookies.get('username'));\n        if (username)\n            username = username.replace(/\"/g, '');\n        messages.forEach((message) => {\n            message.hasVoted = false;\n            if (username) {\n                message.votes.forEach((vote) => {\n                    if (vote.username === username) {\n                        message.hasVoted = true;\n                    }\n                });\n            }\n            message.votes = message.votes.length;\n        });\n        res.json({ messages });\n    }));\n    Router.getAsync('/avatar/:username', (req, res) => __awaiter(void 0, void 0, void 0, function* () {\n        const { username } = req.params;\n        const user = yield radiksData.findOne({ _id: username });\n        let image;\n        if (user.profile.image) {\n            [image] = user.profile.image;\n        }\n        if (image) {\n            return res.redirect(image.contentUrl);\n        }\n        return res.redirect('/static/banana.jpg');\n    }));\n    return Router;\n};\nmodule.exports = makeApiController;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst profile_1 = require(\"./../utils/profile\");\nconst radiks_1 = require(\"radiks\");\nfunction createKeyChain() {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        let seed = process.env.SEED;\n        console.log('seed', seed);\n        let keychain = yield profile_1.initWalletFromSeed(seed);\n        return keychain;\n    });\n}\nexports.createKeyChain = createKeyChain;\nfunction loadServerSession(keychain) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        let id = yield profile_1.createBlockchainIdentity(keychain);\n        let userSession = profile_1.makeUserSession(id.appPrivateKey, id.appPublicKey, id.username, id.profileJSON.decodedToken.payload.claim);\n        yield profile_1.configureRadiks(userSession);\n        let blockstackUser = yield radiks_1.User.createWithCurrentUser();\n        const radiksBatchAccount = {\n            backupPhrase: keychain.backupPhrase,\n            publicKey: id.appPublicKey,\n            privateKey: id.appPrivateKey,\n            userSession: userSession,\n            username: id.username,\n            error: 'none',\n            profileJSON: id.profileJSON\n        };\n        console.log('created radiksBatchAccount for the server! ', radiksBatchAccount);\n        return radiksBatchAccount;\n    });\n}\nexports.loadServerSession = loadServerSession;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nfunction PlaceController(io, socket, room, RadiksController) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        console.log('new joiner ', room);\n        socket.join(room, () => tslib_1.__awaiter(this, void 0, void 0, function* () {\n            console.log(`New client connected to ${room}`);\n            yield createRoomSession();\n            function createRoomSession() {\n                return tslib_1.__awaiter(this, void 0, void 0, function* () {\n                    let session = null;\n                    let placeId = room;\n                    return new Promise((resolve, reject) => {\n                        let placeKey = `place_${placeId}`;\n                        RadiksController.centralCollection.find({ \"_id\": { $regex: placeKey } }).toArray((error, item) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n                            if (item.length > 0) {\n                                session = item;\n                            }\n                            else {\n                            }\n                            socket.emit('message', session);\n                            resolve(session);\n                        }));\n                    });\n                });\n            }\n            function inviteMemberIfNotExists(placeId, userToInvite) {\n            }\n        }));\n    });\n}\nexports.PlaceController = PlaceController;\n;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst express = require('express');\nconst express_1 = require(\"@awaitjs/express\");\nconst minPeopleCount = 5;\nexports.PlaceInfoController = (db) => {\n    const Router = express_1.decorateApp(express.Router());\n    Router.getAsync('/headcount/:geohash', (req, res) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {\n        const { geohash } = req.params;\n        let query = { _id: { $regex: geohash } };\n        let headcount = yield geohashQuery(query);\n        res.json({\n            geohash,\n            count: headcount\n        });\n    }));\n    Router.getAsync('/nearest/populated/:lat/:long', (req, res) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {\n        const { lat, long } = req.params;\n        res.json({ error: 'e' });\n    }));\n    function geohashQuery(query) {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            let cursor = db.collection(\"radiks-central-data\").find(query);\n            let result = yield cursor.toArray();\n            try {\n                const headcount = result[0].group.attrs.members.length;\n                return headcount;\n            }\n            catch (e) {\n                return 0;\n            }\n        });\n    }\n    return Router;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nrequire(\"./LoadEnv\");\nrequire(\"localstorage-polyfill\");\nconst Window = require('window');\nconst window = new Window();\nrequire(\"localstorage-polyfill\");\nconst fetch = require('node-fetch');\nglobal.window = window;\nglobal.document = window.document;\nconst cookie_parser_1 = tslib_1.__importDefault(require(\"cookie-parser\"));\nconst express_1 = tslib_1.__importDefault(require(\"express\"));\nconst morgan_1 = tslib_1.__importDefault(require(\"morgan\"));\nconst path_1 = tslib_1.__importDefault(require(\"path\"));\nconst routes_1 = tslib_1.__importDefault(require(\"./routes\"));\nconst radiks_server_1 = require(\"radiks-server\");\nconst http_status_codes_1 = require(\"http-status-codes\");\nconst PlaceInfoController_1 = require(\"./api/PlaceInfoController\");\nconst Keychain_1 = require(\"./api/Keychain\");\nconst EventEmitter = require('wolfy87-eventemitter');\nconst PlaceController_1 = require(\"./api/PlaceController\");\nconst makeApiController = require('./api/ApiController');\nconst { STREAM_CRAWL_EVENT } = require('radiks-server/app/lib/constants');\nconst app = express_1.default();\napp.use(morgan_1.default('dev'));\napp.use(express_1.default.json());\napp.use(express_1.default.urlencoded({ extended: true }));\napp.use(cookie_parser_1.default());\napp.use('/api', routes_1.default);\nconst viewsDir = path_1.default.join(__dirname, 'views');\napp.set('views', viewsDir);\nconst staticDir = path_1.default.join(__dirname, 'public');\napp.use(express_1.default.static(staticDir));\napp.get('/', (req, res) => {\n    return res.status(http_status_codes_1.OK).json({ 'hi': 'the-local-server' });\n});\napp.get('/manifest.json', (req, res) => {\n    res.header('Access-Control-Allow-Origin', '*');\n    res.header('Access-Control-Allow-Headers', '*');\n    res.sendFile(path_1.default.join(__dirname, '..', 'static', 'manifest.json'));\n});\nconst port = Number(process.env.PORT || 5000);\nconst server = app.listen(port, () => {\n    console.log('Express server started on port: ' + port);\n});\nradiks_server_1.setup().then((RadiksController) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {\n    const io = require('socket.io')(server);\n    app.use('/radiks', RadiksController);\n    app.use('/api', makeApiController(RadiksController.DB));\n    app.use('/placeinfo', PlaceInfoController_1.PlaceInfoController(RadiksController.DB));\n    let keychain = yield Keychain_1.createKeyChain();\n    let session = yield Keychain_1.loadServerSession(keychain);\n    console.log('keychain', keychain);\n    console.log('session', session);\n    RadiksController.emitter.on(STREAM_CRAWL_EVENT, ([attrs]) => {\n        if (attrs.geohash) {\n            let room = attrs.geohash;\n            io.in(room).emit('message', attrs);\n        }\n    });\n    io.on('connection', function (socket) {\n        console.log('new connection');\n        socket.on('join', (room) => {\n            PlaceController_1.PlaceController(io, socket, room, RadiksController);\n        });\n    });\n}));\nexports.default = app;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst express_1 = require(\"express\");\nconst router = express_1.Router();\nexports.default = router;\n","import { decrypt } from './encryption-utils'\nimport { HDNode } from 'bitcoinjs-lib'\nimport crypto from 'crypto'\n\n\nfunction hashCode(string) {\n  let hash = 0\n  if (string.length === 0) return hash\n  for (let i = 0; i < string.length; i++) {\n    const character = string.charCodeAt(i)\n    hash = (hash << 5) - hash + character\n    hash = hash & hash\n  }\n  return hash & 0x7fffffff\n}\n\nconst APPS_NODE_INDEX = 0\nconst SIGNING_NODE_INDEX = 1\nconst ENCRYPTION_NODE_INDEX = 2\nexport const MAX_TRUST_LEVEL = 99\n\nexport class AppNode {\n  constructor(hdNode, appDomain) {\n    this.hdNode = hdNode\n    this.appDomain = appDomain\n  }\n\n  getAppPrivateKey() {\n    return this.hdNode.keyPair.d.toBuffer(32).toString('hex')\n  }\n\n  getAddress() {\n    return this.hdNode.getAddress()\n  }\n}\n\nexport class AppsNode {\n  constructor(appsHdNode, salt) {\n    this.hdNode = appsHdNode\n    this.salt = salt\n  }\n\n  getNode() {\n    return this.hdNode\n  }\n\n  getAppNode(appDomain) {\n    const hash = crypto\n      .createHash('sha256')\n      .update(`${appDomain}${this.salt}`)\n      .digest('hex')\n    const appIndex = hashCode(hash)\n    const appNode = this.hdNode.deriveHardened(appIndex)\n    return new AppNode(appNode, appDomain)\n  }\n\n  toBase58() {\n    return this.hdNode.toBase58()\n  }\n\n  getSalt() {\n    return this.salt\n  }\n}\n\nclass IdentityAddressOwnerNode {\n  constructor(ownerHdNode, salt) {\n    this.hdNode = ownerHdNode\n    this.salt = salt\n  }\n\n  getNode() {\n    return this.hdNode\n  }\n\n  getSalt() {\n    return this.salt\n  }\n\n  getIdentityKey() {\n    return this.hdNode.keyPair.d.toBuffer(32).toString('hex')\n  }\n\n  getIdentityKeyID() {\n    return this.hdNode.keyPair.getPublicKeyBuffer().toString('hex')\n  }\n\n  getAppsNode() {\n    return new AppsNode(this.hdNode.deriveHardened(APPS_NODE_INDEX), this.salt)\n  }\n\n  getAddress() {\n    return this.hdNode.getAddress()\n  }\n\n  getEncryptionNode() {\n    return this.hdNode.deriveHardened(ENCRYPTION_NODE_INDEX)\n  }\n\n  getSigningNode() {\n    return this.hdNode.deriveHardened(SIGNING_NODE_INDEX)\n  }\n}\n\nexport function isPasswordValid(password) {\n  let isValid = false\n  let error = null\n\n  if (password.length >= 8) {\n    isValid = true\n    error = 'Password must be at least 8 characters'\n  }\n\n  return { isValid, error }\n}\n\nexport function isBackupPhraseValid(backupPhrase) {\n  let isValid = true\n  let error = null\n  return import(/* webpackChunkName: 'bip39' */ 'bip39').then(bip39 => {\n    if (!bip39.validateMnemonic(backupPhrase)) {\n      isValid = false\n      error = 'Backup phrase is not a valid set of words'\n    }\n\n    return { isValid, error }\n  })\n}\n\nexport function decryptMasterKeychain(password, encryptedBackupPhrase) {\n  return new Promise((resolve, reject) => {\n    const dataBuffer = new Buffer(encryptedBackupPhrase, 'hex')\n    decrypt(dataBuffer, password).then(\n      async plaintextBuffer => {\n        const bip39 = await import(/* webpackChunkName: 'bip39' */ 'bip39')\n        const backupPhrase = plaintextBuffer.toString()\n        const seed = bip39.mnemonicToSeed(backupPhrase)\n        const masterKeychain = HDNode.fromSeedBuffer(seed)\n        //logger.info('decryptMasterKeychain: decrypted!')\n        resolve(masterKeychain)\n      },\n      error => {\n        //logger.error('decryptMasterKeychain: error', error)\n        reject(new Error('Incorrect password'))\n      }\n    )\n  })\n}\n\nconst EXTERNAL_ADDRESS = 'EXTERNAL_ADDRESS'\nconst CHANGE_ADDRESS = 'CHANGE_ADDRESS'\n\nexport function getBitcoinPrivateKeychain(masterKeychain) {\n  const BIP_44_PURPOSE = 44\n  const BITCOIN_COIN_TYPE = 0\n  const ACCOUNT_INDEX = 0\n\n  return masterKeychain\n    .deriveHardened(BIP_44_PURPOSE)\n    .deriveHardened(BITCOIN_COIN_TYPE)\n    .deriveHardened(ACCOUNT_INDEX)\n}\n\nexport function getBitcoinPublicKeychain(masterKeychain) {\n  return getBitcoinPrivateKeychain(masterKeychain).neutered()\n}\n\nexport function getBitcoinAddressNode(\n  bitcoinKeychain,\n  addressIndex = 0,\n  chainType = EXTERNAL_ADDRESS\n) {\n  let chain = null\n\n  if (chainType === EXTERNAL_ADDRESS) {\n    chain = 0\n  } else if (chainType === CHANGE_ADDRESS) {\n    chain = 1\n  } else {\n    throw new Error('Invalid chain type')\n  }\n\n  return bitcoinKeychain.derive(chain).derive(addressIndex)\n}\n\nexport function decryptBitcoinPrivateKey(password, encryptedBackupPhrase) {\n  return new Promise((resolve, reject) =>\n    decryptMasterKeychain(password, encryptedBackupPhrase)\n      .then(masterKeychain => {\n        const bitcoinPrivateKeychain = getBitcoinPrivateKeychain(masterKeychain)\n        const bitcoinAddressHDNode = getBitcoinAddressNode(\n          bitcoinPrivateKeychain,\n          0\n        )\n        const privateKey = bitcoinAddressHDNode.keyPair.d\n          .toBuffer(32)\n          .toString('hex')\n        resolve(privateKey)\n      })\n      .catch(error => {\n        reject(error)\n      })\n  )\n}\n\nconst IDENTITY_KEYCHAIN = 888\nconst BLOCKSTACK_ON_BITCOIN = 0\nexport function getIdentityPrivateKeychain(masterKeychain) {\n  return masterKeychain\n    .deriveHardened(IDENTITY_KEYCHAIN)\n    .deriveHardened(BLOCKSTACK_ON_BITCOIN)\n}\n\nexport function getIdentityPublicKeychain(masterKeychain) {\n  return getIdentityPrivateKeychain(masterKeychain).neutered()\n}\n\nexport function getIdentityOwnerAddressNode(\n  identityPrivateKeychain,\n  identityIndex = 0\n) {\n  if (identityPrivateKeychain.isNeutered()) {\n    throw new Error('You need the private key to generate identity addresses')\n  }\n\n  const publicKeyHex = identityPrivateKeychain.keyPair\n    .getPublicKeyBuffer()\n    .toString('hex')\n  const salt = crypto\n    .createHash('sha256')\n    .update(publicKeyHex)\n    .digest('hex')\n\n  return new IdentityAddressOwnerNode(\n    identityPrivateKeychain.deriveHardened(identityIndex),\n    salt\n  )\n}\n\nexport function deriveIdentityKeyPair(identityOwnerAddressNode) {\n  const address = identityOwnerAddressNode.getAddress()\n  const identityKey = identityOwnerAddressNode.getIdentityKey()\n  const identityKeyID = identityOwnerAddressNode.getIdentityKeyID()\n  const appsNode = identityOwnerAddressNode.getAppsNode()\n  const keyPair = {\n    key: identityKey,\n    keyID: identityKeyID,\n    address,\n    appsNodeKey: appsNode.toBase58(),\n    salt: appsNode.getSalt()\n  }\n  return keyPair\n}\n\nexport function getWebAccountTypes(api) {\n  const webAccountTypes = {\n    twitter: {\n      label: 'Twitter',\n      iconClass: 'fa-twitter',\n      social: true,\n      urlTemplate: 'https://twitter.com/{identifier}'\n    },\n    facebook: {\n      label: 'Facebook',\n      iconClass: 'fa-facebook',\n      social: true,\n      urlTemplate: 'https://facebook.com/{identifier}'\n    },\n    github: {\n      label: 'GitHub',\n      iconClass: 'fa-github-alt',\n      social: true,\n      urlTemplate: 'https://github.com/{identifier}'\n    },\n    instagram: {\n      label: 'Instagram',\n      iconClass: 'fa-instagram',\n      social: true,\n      urlTemplate: 'https://instagram.com/{identifier}'\n    },\n    linkedIn: {\n      label: 'LinkedIn',\n      iconClass: 'fa-linkedin',\n      social: true,\n      urlTemplate: 'https://www.linkedin.com/in/{identifier}'\n    },\n    tumblr: {\n      label: 'Tumblr',\n      iconClass: 'fa-tumblr',\n      social: true,\n      urlTemplate: 'http://{identifier}.tumblr.com'\n    },\n    reddit: {\n      label: 'Reddit',\n      iconClass: 'fa-reddit-alien',\n      social: true,\n      urlTemplate: 'https://www.reddit.com/user/{identifier}'\n    },\n    pinterest: {\n      label: 'Pinterest',\n      iconClass: 'fa-pinterest',\n      social: true,\n      urlTemplate: 'https://pinterest.com/{identifier}'\n    },\n    youtube: {\n      label: 'YouTube',\n      iconClass: 'fa-youtube',\n      social: true,\n      urlTemplate: 'https://www.youtube.com/channel/{identifier}'\n    },\n    'google-plus': {\n      label: 'Google+',\n      iconClass: 'fa-google-plus',\n      social: true,\n      urlTemplate: 'https://plus.google.com/u/{identifier}'\n    },\n    angellist: {\n      label: 'AngelList',\n      iconClass: 'fa-angellist',\n      social: true,\n      urlTemplate: 'https://angel.co/{identifier}'\n    },\n    'stack-overflow': {\n      label: 'StackOverflow',\n      iconClass: 'fa-stack-overflow',\n      social: true,\n      urlTemplate: 'http://stackoverflow.com/users/{identifier}'\n    },\n    hackerNews: {\n      label: 'Hacker News',\n      iconClass: 'fa-hacker-news',\n      social: true,\n      urlTemplate: 'https://news.ycombinator.com/user?id={identifier}'\n    },\n    openbazaar: {\n      label: 'OpenBazaar',\n      iconClass: 'fa-shopping-cart',\n      social: true,\n      urlTemplate: 'ob://{identifier}'\n    },\n    snapchat: {\n      label: 'Snapchat',\n      iconClass: 'fa-snapchat-ghost',\n      social: true,\n      urlTemplate: 'https://snapchat.com/add/{identifier}'\n    },\n    website: {\n      label: 'Website',\n      iconClass: 'fa-link',\n      social: false,\n      urlTemplate: '{identifier}'\n    },\n    ssh: {\n      label: 'SSH',\n      iconClass: 'fa-key',\n      social: false\n    },\n    pgp: {\n      label: 'PGP',\n      iconClass: 'fa-key',\n      social: false\n    },\n    bitcoin: {\n      label: 'Bitcoin',\n      iconClass: 'fa-bitcoin',\n      social: false,\n      urlTemplate: api.bitcoinAddressUrl\n    },\n    ethereum: {\n      label: 'Ethereum',\n      iconClass: 'fa-key',\n      social: false,\n      urlTemplate: api.ethereumAddressUrl\n    }\n  }\n  return webAccountTypes\n}\n\nexport function calculateTrustLevel(verifications) {\n  if (!verifications || verifications.length < 1) {\n    return 0\n  }\n\n  let trustLevel = 0\n  verifications.forEach(verification => {\n    if (verification.valid && trustLevel < MAX_TRUST_LEVEL) {\n      trustLevel++\n    }\n  })\n\n  return trustLevel\n}\n\nexport function calculateProfileCompleteness(profile, verifications) {\n  let complete = 0\n  const totalItems = 2\n  const maxVerificationItems = 1\n\n  if (profile.name && profile.name.length > 0) {\n    complete++\n  }\n\n  // if (profile.description && profile.description.length > 0) {\n  //   complete++\n  // }\n\n  // if (profile.image && profile.image.length > 0) {\n  //   complete++\n  // }\n\n  complete += Math.min(calculateTrustLevel(verifications), maxVerificationItems)\n\n  return complete / totalItems\n}\n\nexport function findAddressIndex(address, identityAddresses) {\n  for (let i = 0; i < identityAddresses.length; i++) {\n    if (identityAddresses[i] === address) {\n      return i\n    }\n  }\n  return null\n}\n\nexport function getBlockchainIdentities(masterKeychain, identitiesToGenerate) {\n  const identityPrivateKeychainNode = getIdentityPrivateKeychain(masterKeychain)\n  const bitcoinPrivateKeychainNode = getBitcoinPrivateKeychain(masterKeychain)\n\n  const identityPublicKeychainNode = identityPrivateKeychainNode.neutered()\n  const identityPublicKeychain = identityPublicKeychainNode.toBase58()\n\n  const bitcoinPublicKeychainNode = bitcoinPrivateKeychainNode.neutered()\n  const bitcoinPublicKeychain = bitcoinPublicKeychainNode.toBase58()\n\n  const firstBitcoinAddress = getBitcoinAddressNode(\n    bitcoinPublicKeychainNode\n  ).getAddress()\n\n  const identityAddresses = []\n  const identityKeypairs = []\n\n  // We pre-generate a number of identity addresses so that we\n  // don't have to prompt the user for the password on each new profile\n  for (\n    let addressIndex = 0;\n    addressIndex < identitiesToGenerate;\n    addressIndex++\n  ) {\n    const identityOwnerAddressNode = getIdentityOwnerAddressNode(\n      identityPrivateKeychainNode,\n      addressIndex\n    )\n    const identityKeyPair = deriveIdentityKeyPair(identityOwnerAddressNode)\n    identityKeypairs.push(identityKeyPair)\n    identityAddresses.push(identityKeyPair.address)\n    //logger.debug(`createAccount: identity index: ${addressIndex}`)\n  }\n\n  return {\n    identityPublicKeychain,\n    bitcoinPublicKeychain,\n    firstBitcoinAddress,\n    identityAddresses,\n    identityKeypairs\n  }\n}","import hash from 'hash-handler'\n\n\nconst logger = console;\n\nimport {\n  DEFAULT_CORE_API_ENDPOINT, REGTEST_CORE_API_ENDPOINT, REGTEST_CORE_API_PASSWORD,\n  DEFAULT_CORE_PHONY_PASSWORD }  from './browser/store/settings/default'\n\n\nimport { isCoreEndpointDisabled } from './window-utils'\nvar BLOCKSTACK_STATE_VERSION_KEY = 'BLOCKSTACK_STATE_VERSION';\n\nexport function authorizationHeaderValue(coreAPIPassword) {\n  return `bearer ${coreAPIPassword}`\n}\n\nexport function getCoreAPIPasswordFromURL() {\n  const coreAPIPassword = hash.getInstance().get('coreAPIPassword')\n  if (!coreAPIPassword || coreAPIPassword === 'off') {\n    return null\n  }\n  hash.getInstance().set('coreAPIPassword', 'off')\n  return coreAPIPassword\n}\n\nexport function getLogServerPortFromURL() {\n  const logServerPort = hash.getInstance().get('logServerPort')\n  if (!logServerPort || logServerPort === 'off') {\n    return null\n  }\n  hash.getInstance().set('logServerPort', 'off')\n  return logServerPort\n}\n\nexport function getRegTestModeFromURL() {\n  const regTestMode = hash.getInstance().get('regtest')\n  if (!regTestMode || regTestMode === 'off') {\n    return null\n  }\n  hash.getInstance().set('regtest', 'off')\n  return regTestMode === '1'\n}\n\nfunction findAndSetApiUrls(api, regTestMode, coreAPIPassword, toFindUrl, toSetUrl) {\n  const apiOut = Object.assign({}, api, { regTestMode, coreAPIPassword })\n  Object.keys(apiOut)\n    .forEach(key => {\n      const value = apiOut[key]\n      if (typeof value === 'string' || value instanceof String) {\n        if (value.startsWith(toFindUrl)) {\n          const suffix = value.slice(toFindUrl.length)\n          apiOut[key] = `${toSetUrl}${suffix}`\n        }\n      }\n    })\n\n  return apiOut\n}\n\n/**\n * Returns an API object with regTestMode set to the inputted value,\n *  and URLs all changed to either match DEFAULT_CORE_API_ENDPOINT\n *  or REGTEST_CORE_API_ENDPOINT respectively.\n *\n * This is intended _only_ as a stopgap implementation. Realistically,\n *  we need a more sophisticated regtest mode, which will restore\n *  to the correct URLs\n * @parameter {Object} the previous api object\n * @parameter {Object} the new value of the regTestMode\n * @returns {Object} a new api object\n * @private\n */\nexport function setOrUnsetUrlsToRegTest(api, regTestMode) {\n  let toFindUrl\n  let toSetUrl\n  let coreAPIPassword\n  if (regTestMode) {\n    toFindUrl = DEFAULT_CORE_API_ENDPOINT\n    toSetUrl = REGTEST_CORE_API_ENDPOINT\n    coreAPIPassword = REGTEST_CORE_API_PASSWORD\n  } else {\n    toFindUrl = REGTEST_CORE_API_ENDPOINT\n    toSetUrl = DEFAULT_CORE_API_ENDPOINT\n    coreAPIPassword = DEFAULT_CORE_PHONY_PASSWORD\n  }\n  return findAndSetApiUrls(api, regTestMode, coreAPIPassword, toFindUrl, toSetUrl)\n}\n\n/*\n * Returns true if the current state version is a legacy version\n *  which relies on localhost:6270 -- this is true if the\n *  existing state version is < 13 (when we migrated away from shipping a\n *  local api endpoint)\n * @returns {boolean}\n * @private\n */\nexport function hasLegacyCoreStateVersion() {\n  let existingVersion = localStorage.getItem(BLOCKSTACK_STATE_VERSION_KEY)\n  if (!existingVersion) {\n    existingVersion = 0\n  }\n  return existingVersion < 13\n}\n\n/**\n * Migrates an API object from old default URLs to the new\n *  default. Used in migrating from localhost:6270 default to\n *  core.blockstack.org (happened at v0.28.0)\n * @parameter {Object} the previous api object\n * @returns {Object} a new api object\n * @private\n */\nexport function migrateLegacyCoreEndpoints(api) {\n  // State version 13 is when we migrated away from default localhost:6270\n  console.log('Migrating URLs from localhost:6270 to core.blockstack.org')\n  const regTestMode = api.regTestMode\n  const toFindUrl = 'http://localhost:6270'\n  const toSetUrl = DEFAULT_CORE_API_ENDPOINT\n  const coreAPIPassword = DEFAULT_CORE_PHONY_PASSWORD\n  const outApi = findAndSetApiUrls(api, regTestMode, coreAPIPassword, toFindUrl, toSetUrl)\n  console.log(JSON.stringify(outApi))\n  return outApi\n}\n\nexport function isCoreApiRunning(corePingUrl) {\n  if (isCoreEndpointDisabled(corePingUrl)) {\n    return new Promise(resolve => {\n      resolve(true)\n    })\n  }\n\n  logger.debug(`isCoreApiRunning: ${corePingUrl}`)\n\n  return new Promise(resolve => {\n    fetch(corePingUrl, { cache: 'no-store' })\n      .then(response => response.text())\n      .then(responseText => JSON.parse(responseText))\n      .then(responseJson => {\n        if (responseJson.status === 'alive') {\n          logger.info('isCoreApiRunning? Yes!')\n          resolve(true)\n        } else {\n          logger.error('isCoreApiRunning? No!')\n          resolve(false)\n        }\n      })\n      .catch(error => {\n        logger.error(`isCoreApiRunning: problem checking ${corePingUrl}`, error)\n        resolve(false)\n      })\n  })\n}\n\nexport function isApiPasswordValid(corePasswordProtectedReadUrl, coreApiPassword) {\n  if (isCoreEndpointDisabled(corePasswordProtectedReadUrl)) {\n    return new Promise(resolve => {\n      resolve(true)\n    })\n  }\n\n  logger.debug(`isApiPasswordValid: ${corePasswordProtectedReadUrl}`)\n\n  const requestHeaders = {\n    Accept: 'application/json',\n    'Content-Type': 'application/json',\n    Authorization: authorizationHeaderValue(coreApiPassword)\n  }\n\n  return new Promise(resolve => {\n    if (!coreApiPassword) {\n      logger.error('isCoreApiPasswordValid? Password is missing!')\n      resolve(false)\n      return\n    }\n    fetch(corePasswordProtectedReadUrl, {\n      cache: 'no-store',\n      headers: requestHeaders\n    })\n      .then(response => {\n        if (response.ok) {\n          logger.info('isCoreApiPasswordValid? Yes!')\n          resolve(true)\n        } else {\n          logger.error('isCoreApiPasswordValid? No!')\n          resolve(false)\n        }\n      })\n      .catch(error => {\n        logger.error(`isApiPasswordValid: problem checking ${corePasswordProtectedReadUrl}`, error)\n        resolve(false)\n      })\n  })\n}\n\n/* Expects a JavaScript object with a key containing the config for each storage\n * provider\n * Example:\n * const config = { dropbox: { token: '123abc'} }\n */\nexport function setCoreStorageConfig() {\n  logger.debug('setCoreStorageConfig called in a core-less build')\n  return Promise.resolve('OK')\n}\n","\nimport { Transaction, address as Address } from 'bitcoinjs-lib'\nimport {\n  REGTEST_CORE_API_PASSWORD,\n  REGTEST_CORE_INSIGHT_API_URL\n} from './browser/store/settings/default'\n\nconst logger = console;\n\nconst SATOSHIS_IN_BTC = 100000000\n\nexport function btcToSatoshis(amountInBtc) {\n  return amountInBtc * SATOSHIS_IN_BTC\n}\n\nexport function satoshisToBtc(amountInSatoshis) {\n  return 1.0 * amountInSatoshis / SATOSHIS_IN_BTC\n}\n\nexport function broadcastTransaction(broadcastTransactionUrl, rawTransaction) {\n  return new Promise((resolve, reject) => {\n    const payload = { rawtx: rawTransaction }\n\n    fetch(broadcastTransactionUrl, {\n      headers: {\n        Accept: 'application/json',\n        'Content-Type': 'application/json'\n      },\n      method: 'POST',\n      body: JSON.stringify(payload)\n    })\n      .then(response => response.text())\n      .then(responseText => JSON.parse(responseText))\n      .then(responseJson => {\n        resolve(responseJson)\n      })\n      .catch(error => {\n        logger.error('broadcastTransaction: error broadcasting transaction', error)\n        reject(error)\n      })\n  })\n}\n\nexport function getInsightUrls(insightUrl, address, coreAPIPassword) {\n  console.log(`constant: ${REGTEST_CORE_API_PASSWORD}, parameter: ${coreAPIPassword}`)\n  if (coreAPIPassword === REGTEST_CORE_API_PASSWORD) {\n    logger.debug('getInsightUrls: using regtest mock insight api ')\n    insightUrl = REGTEST_CORE_INSIGHT_API_URL\n  }\n  const url = insightUrl.replace('{address}', address)\n  return {\n    base: url,\n    confirmedBalanceUrl: `${url}/balance`,\n    unconfirmedBalanceUrl: `${url}/unconfirmedBalance`\n  }\n}\n\nexport function getNetworkFee(bytes) {\n  return new Promise((resolve, reject) => {\n    fetch('https://bitcoinfees.21.co/api/v1/fees/recommended')\n      .then(response => response.text())\n      .then(responseText => JSON.parse(responseText))\n      .then(responseJson => {\n        const satoshisPerByte = responseJson.fastestFee\n        const fee = bytes * satoshisPerByte\n        resolve(fee)\n      })\n      .catch(error => {\n        reject(error)\n      })\n  })\n}\n\n/**\n * Constructs a summary of what the users sending from a transaction hex\n * @param {string} txHex - Encoded transaction hex\n * @return {{ outs: { address: string, satoshis: number }[], total: number }}\n */\nexport function summarizeTransactionFromHex(txHex) {\n  const tx = Transaction.fromHex(txHex)\n  const outs = tx.outs.map(o => ({\n    address: Address.fromOutputScript(o.script),\n    satoshis: o.value\n  }))\n  return {\n    outs,\n    total: outs.reduce((prev, o) => prev + o.satoshis, 0)\n  }\n}\n","import crypto from 'crypto'\nexport const BLOCKSTACK_INC = 'gaia-hub'\n\nexport const REGTEST_CORE_API_PASSWORD = 'blockstack_integration_test_api_password'\nexport const DEFAULT_CORE_PHONY_PASSWORD = 'PretendPasswordAPI'\nexport const REGTEST_CORE_INSIGHT_API_URL = 'http://localhost:6270/insight-api/addr/{address}'\n\n// DEFAULT_API values are only used if\n// the user's settings.api state doesn't\n// already have an existing key.\n// To change a value, use a new key.\n\nexport const DEFAULT_CORE_API_ENDPOINT = 'https://core.blockstack.org'\nexport const REGTEST_CORE_API_ENDPOINT = 'http://localhost:6270'\n\nconst DEFAULT_API = {\n  apiCustomizationEnabled: true,\n  nameLookupUrl: `${DEFAULT_CORE_API_ENDPOINT}/v1/names/{name}`,\n  searchServiceUrl: 'https://core.blockstack.org/v1/search?query={query}',\n  registerUrl: `${DEFAULT_CORE_API_ENDPOINT}/v1/names`,\n  bitcoinAddressLookupUrl: `${DEFAULT_CORE_API_ENDPOINT}/v1/addresses/bitcoin/{address}`,\n  zeroConfBalanceUrl: `${DEFAULT_CORE_API_ENDPOINT}/v1/wallet/balance/0`,\n  insightUrl: 'https://utxo.blockstack.org/insight-api/addr/{address}',\n  btcBalanceUrl: 'https://blockchain.info/q/addressbalance/',\n  broadcastUrl: 'https://utxo.blockstack.org/insight-api/tx/send',\n  priceUrl: `${DEFAULT_CORE_API_ENDPOINT}/v2/prices/names/{name}`,\n  networkFeeUrl: 'https://bitcoinfees.21.co/api/v1/fees/recommended',\n  walletPaymentAddressUrl: `${DEFAULT_CORE_API_ENDPOINT}/v1/wallet/payment_address`,\n  pendingQueuesUrl: `${DEFAULT_CORE_API_ENDPOINT}/v1/blockchains/bitcoin/pending`,\n  coreWalletWithdrawUrl: `${DEFAULT_CORE_API_ENDPOINT}/v1/wallet/balance`,\n  bitcoinAddressUrl: 'https://explorer.blockstack.org/address/{identifier}',\n  ethereumAddressUrl: 'https://tradeblock.com/ethereum/account/{identifier}',\n  pgpKeyUrl: 'https://pgp.mit.edu/pks/lookup?search={identifier}&op=vindex&fingerprint=on',\n  btcPriceUrl: 'https://www.bitstamp.net/api/v2/ticker/btcusd/?cors=1',\n  corePingUrl: `${DEFAULT_CORE_API_ENDPOINT}/v1/node/ping`,\n  zoneFileUrl: `${DEFAULT_CORE_API_ENDPOINT}/v1/names/{name}/zonefile`,\n  nameTransferUrl: `${DEFAULT_CORE_API_ENDPOINT}/v1/names/{name}/owner`,\n  subdomains: {\n    'foo.id': {\n      registerUrl: 'http://localhost:7103/register',\n      apiUrl: 'http://localhost:7103/v1/names'\n    },\n    'test-personal.id': {\n      registerUrl: 'https://test-registrar.blockstack.org/register',\n      apiUrl: 'https://test-registrar.blockstack.org/v1/names'\n    },\n    'id.blockstack': {\n      registerUrl: 'https://registrar.blockstack.org/register',\n      apiUrl: 'https://registrar.blockstack.org/v1/names'\n    }\n  },\n  browserServerUrl: 'https://blockstack-browser-server.appartisan.com',\n  hostedDataLocation: BLOCKSTACK_INC,\n  coreHost: 'localhost',\n  corePort: 6270,\n  coreAPIPassword: DEFAULT_CORE_PHONY_PASSWORD,\n  logServerPort: '',\n  regTestMode: false,\n  storageConnected: false,\n  gaiaHubConfig: null,\n  gaiaHubUrl: 'https://hub.blockstack.org',\n  btcPrice: '1000.00',\n  distinctEventId: crypto.randomBytes(16).toString('hex'),\n  hasDisabledEventTracking: false\n}\n\nexport default DEFAULT_API\n","import bip39 from 'bip39'\n\nimport cryptoCheck from './workers/crypto-check.worker.js'\nimport makeEncryptWorker from './workers/encrypt.worker.js'\nimport * as encryptMain from './workers/encrypt.main.js'\nimport makeDecryptWorker from './workers/decrypt.worker.js'\nimport * as decryptMain from './workers/decrypt.main.js'\n\nconst logger = console;\n\nasync function checkCryptoWorkerSupport() {\n  const result = await cryptoCheck().isCryptoInWorkerSupported() \n  return result.toString() === 'true'\n}\n\nexport async function encrypt(plaintextBuffer, password) {\n  const mnemonic = plaintextBuffer.toString()\n  const useWorker = await checkCryptoWorkerSupport()\n  let encryptLib\n  if (useWorker) {\n    encryptLib = makeEncryptWorker()\n  } else {\n    encryptLib = encryptMain\n  }\n  return encryptLib.encrypt(mnemonic, password)\n}\n\nexport async function decrypt(dataBuffer, password) {\n  const encryptedMnemonic = dataBuffer.toString('hex')\n  const useWorker = await checkCryptoWorkerSupport()\n  let decryptLib\n  if (useWorker) {\n    decryptLib = makeDecryptWorker()\n  } else {\n    decryptLib = decryptMain\n  }\n  const mnemonic = await decryptLib.decrypt(encryptedMnemonic, password)\n  return Buffer.from(mnemonic)\n}\n\nexport const RECOVERY_TYPE = {\n  MNEMONIC: 'mnemonic',\n  ENCRYPTED: 'encrypted'\n}\n\n/**\n * Checks if a recovery option is valid, and attempts to clean it up.\n * @param {string} input - User input of recovery method\n * @returns {{ isValid: boolean, cleaned: (string|undefined), type: (string|undefined) }}\n */\nexport function validateAndCleanRecoveryInput(input) {\n  logger.debug('Validate and clean recovery input')\n  const cleaned = input.trim()\n  logger.debug('cleaned: ', cleaned)\n\n  // Raw mnemonic phrase\n  const cleanedMnemonic = cleaned\n    .toLowerCase()\n    .split(/\\s|-|_|\\./)\n    .join(' ')\n\n  if (bip39.validateMnemonic(cleanedMnemonic)) {\n    logger.debug('This is a valid mnemonic.')\n    return {\n      isValid: true,\n      type: RECOVERY_TYPE.MNEMONIC,\n      cleaned: cleanedMnemonic\n    }\n  }\n  logger.debug('Is not a valid mnemonic.')\n\n  // Base64 encoded encrypted phrase\n  let cleanedEncrypted = cleaned.replace(/\\s/gm, '')\n\n  if (\n    /^[a-zA-Z0-9\\+\\/]+=?$/.test(cleanedEncrypted) &&\n    cleanedEncrypted.slice(-1) !== '='\n  ) {\n    // Append possibly missing equals sign padding\n    logger.debug('Encrypted Phrase needs an `=` at the end.')\n\n    cleanedEncrypted = `${cleanedEncrypted}=`\n  }\n\n  if (\n    cleanedEncrypted.length >= 108 &&\n    /^[a-zA-Z0-9\\+\\/]+=$/.test(cleanedEncrypted)\n  ) {\n    logger.debug('Valid encrypted phrase!')\n    return {\n      isValid: true,\n      type: RECOVERY_TYPE.ENCRYPTED,\n      cleaned: cleanedEncrypted\n    }\n  }\n  logger.debug('Is not a valid phrase!')\n\n  return { isValid: false }\n}\n","export {\n  decryptMasterKeychain,\n  deriveIdentityKeyPair,\n  getBitcoinPrivateKeychain,\n  getBitcoinPublicKeychain,\n  getIdentityPrivateKeychain,\n  getIdentityPublicKeychain,\n  getWebAccountTypes,\n  isPasswordValid,\n  isBackupPhraseValid,\n  getIdentityOwnerAddressNode,\n  getBitcoinAddressNode,\n  findAddressIndex,\n  decryptBitcoinPrivateKey,\n  calculateTrustLevel,\n  calculateProfileCompleteness,\n  getBlockchainIdentities\n} from './account-utils'\n\nexport { authorizationHeaderValue } from './api-utils'\n\nexport {\n  broadcastTransaction,\n  btcToSatoshis,\n  getNetworkFee,\n  getInsightUrls,\n  satoshisToBtc\n} from './bitcoin-utils'\n\nexport { getNumberOfVerifications, compareProfilesByVerifications } from './search-utils'\n\nexport { encrypt, decrypt } from './encryption-utils'\n\nexport {\n  isABlockstackName,\n  hasNameBeenPreordered,\n  isNameAvailable,\n  isSubdomain,\n  getNamePrices\n} from './name-utils'\n\nexport { getProfileFromTokens, signProfileForUpload, verifyToken, DEFAULT_PROFILE } from './profile-utils'\n\nexport { openInNewTab, isMobile } from './window-utils'\n\nexport {\n  getTokenFileUrlFromZoneFile,\n  resolveZoneFileToProfile\n} from './zone-utils'\n","\n\nconst logger = console;\n\nexport function isABlockstackName(s) {\n  return /^[a-z0-9_-]+\\.[a-z0-9_-]+$/.test(s)\n}\n\nexport function isABlockstackIDName(s) {\n  return /^[a-z0-9_]+\\.id$/.test(s)\n}\n\nexport function isABlockstackAppName(s) {\n  return /^[a-z0-9-]+\\.app$/.test(s)\n}\n\nexport function hasNameBeenPreordered(domainName, localIdentities) {\n  let nameHasBeenPreordered = false\n  localIdentities.map((identity) => {\n    if (identity.username === domainName) {\n      nameHasBeenPreordered = true\n    }\n    return null\n  })\n  return nameHasBeenPreordered\n}\n\nexport function isNameAvailable(lookupUrl, domainName) {\n  console.log(domainName)\n  return new Promise((resolve, reject) => {\n    const url = lookupUrl.replace('{name}', domainName)\n    fetch(url)\n      .then(response => {\n        if (response.ok) {\n          resolve(false)\n        } else {\n          if (response.status === 404) {\n            resolve(true)\n          } else {\n            logger.error('isNameAvailable', response)\n            reject('Error')\n          }\n        }\n      })\n      .catch(error => {\n        logger.error('isNameAvailable', error)\n        reject(error)\n      })\n  })\n}\n\n/**\n * Performs a basic check to differentiate subdomains from other Blockstack\n * names\n * @param  {String}  name a Blockstack name\n * @return {Boolean} `true` if it is a subdomain, otherwise false\n */\nexport function isSubdomain(name) {\n  return name.split('.').length === 3\n}\n\n/**\n * Given a blockstack subdomain name, returns the\n * parent domain.\n * @param  {String} name a Blockstack subdomain name\n * @return {String}  the parent domain without leading period\n */\nexport function getNameSuffix(name) {\n  if (!isSubdomain(name)) {\n    throw new Error('Only works with subdomains')\n  }\n  const nameTokens = name.split('.')\n  const suffix = name.split(`${nameTokens[0]}.`)[1]\n  return suffix\n}\n\nexport function getNamePrices(priceUrl, domainName) {\n  return new Promise((resolve, reject) => {\n    if (!isABlockstackName(domainName)) {\n      reject('Not a Blockstack name')\n      return\n    }\n\n    const url = `${priceUrl.replace('{name}', domainName)}?single_sig=1`\n\n    fetch(url)\n      .then()\n      .then(response => {\n        if (response.ok) {\n          response\n            .text()\n            .then(responseText => JSON.parse(responseText))\n            .then(responseJson => {\n              resolve(responseJson)\n            })\n        } else {\n          logger.error('getNamePrices: error parsing price result')\n          reject('Error')\n        }\n      })\n      .catch(error => {\n        logger.error('getNamePrices: error retrieving price', error)\n        reject(error)\n      })\n  })\n}\n","import { signProfileToken, wrapProfileToken } from 'blockstack'\nimport { decodeToken, TokenVerifier } from 'jsontokens'\n\nimport ecurve from 'ecurve'\nimport { ECPair as ECKeyPair } from 'bitcoinjs-lib'\n\n\nconst logger = console;\n\nconst secp256k1 = ecurve.getCurveByName('secp256k1')\n\nexport function verifyToken(token, verifyingKeyOrAddress) {\n  const decodedToken = decodeToken(token)\n  const payload = decodedToken.payload\n\n  if (!payload.hasOwnProperty('subject')) {\n    throw new Error('Token doesn\\'t have a subject')\n  }\n  if (!payload.subject.hasOwnProperty('publicKey')) {\n    throw new Error('Token doesn\\'t have a subject public key')\n  }\n  if (!payload.hasOwnProperty('issuer')) {\n    throw new Error('Token doesn\\'t have an issuer')\n  }\n  if (!payload.issuer.hasOwnProperty('publicKey')) {\n    throw new Error('Token doesn\\'t have an issuer public key')\n  }\n  if (!payload.hasOwnProperty('claim')) {\n    throw new Error('Token doesn\\'t have a claim')\n  }\n\n  const issuerPublicKey = payload.issuer.publicKey\n  const publicKeyBuffer = new Buffer(issuerPublicKey, 'hex')\n\n  const Q = ecurve.Point.decodeFrom(secp256k1, publicKeyBuffer)\n  const compressedKeyPair = new ECKeyPair(null, Q, { compressed: true })\n  const compressedAddress = compressedKeyPair.getAddress()\n  const uncompressedKeyPair = new ECKeyPair(null, Q, { compressed: false })\n  const uncompressedAddress = uncompressedKeyPair.getAddress()\n\n  if (verifyingKeyOrAddress === issuerPublicKey) {\n    // pass\n  } else if (verifyingKeyOrAddress === compressedAddress) {\n    // pass\n  } else if (verifyingKeyOrAddress === uncompressedAddress) {\n    // pass\n  } else {\n    throw new Error('Token issuer public key does not match the verifying value')\n  }\n\n  const tokenVerifier = new TokenVerifier(decodedToken.header.alg, issuerPublicKey)\n  if (!tokenVerifier) {\n    throw new Error('Invalid token verifier')\n  }\n\n  const tokenVerified = tokenVerifier.verify(token)\n  if (!tokenVerified) {\n    throw new Error('Token verification failed')\n  }\n\n  return decodedToken\n}\n\nexport function verifyTokenRecord(tokenRecord, publicKeyOrAddress) {\n  if (publicKeyOrAddress === null) {\n    throw new Error('A public key or keychain is required')\n  }\n\n  if (typeof publicKeyOrAddress === 'string') {\n    // do nothing\n  } else {\n    throw new Error('A valid address or public key is required')\n  }\n\n  const decodedToken = verifyToken(tokenRecord.token, publicKeyOrAddress)\n\n  return decodedToken\n}\n\nexport function getProfileFromTokens(tokenRecords, publicKeychain, silentVerify = true) {\n  let profile = {}\n\n  tokenRecords.map(tokenRecord => {\n    let decodedToken = null\n\n    try {\n      decodedToken = decodeToken(tokenRecord.token)\n      decodedToken = verifyTokenRecord(tokenRecord, publicKeychain)\n    } catch (error) {\n      if (!silentVerify) {\n        throw error\n      } else {\n        console.warn(error)\n      }\n    }\n\n    if (decodedToken !== null) {\n      profile = Object.assign({}, profile, decodedToken.payload.claim)\n    }\n\n    return null\n  })\n\n  return profile\n}\n\nexport function getDefaultProfileUrl(gaiaUrlBase,\n                                     ownerAddress) {\n  return `${gaiaUrlBase}${ownerAddress}/profile.json`\n}\n\n/**\n * Try to fetch and verify a profile from the historic set of default locations,\n * in order of recency. If all of them return 404s, or fail to validate, return null\n */\nexport function fetchProfileLocations(gaiaUrlBase,\n                                      ownerAddress,\n                                      firstAddress,\n                                      ownerIndex) {\n  function recursiveTryFetch(locations) {\n    if (locations.length === 0) {\n      return Promise.resolve(null)\n    }\n    const location = locations[0]\n    return fetch(location)\n      .then(response => {\n        if (response.ok) {\n          return response.json()\n            .then(tokenRecords => getProfileFromTokens(tokenRecords, ownerAddress, false))\n            .then(profile => {\n              logger.debug(`Found valid profile at ${location}`)\n              return { profile, profileUrl: location }\n            })\n            .catch(() => {\n              logger.debug(`Failed to verify profile at ${location}... trying others`)\n              return recursiveTryFetch(locations.slice(1))\n            })\n        } else {\n          logger.debug(`Failed to find profile at ${location}... trying others`)\n          return recursiveTryFetch(locations.slice(1))\n        }\n      })\n      .catch(() => {\n        logger.debug(`Error in fetching profile at ${location}... trying others`)\n        return recursiveTryFetch(locations.slice(1))\n      })\n  }\n\n  const urls = []\n  // the new default\n  urls.push(getDefaultProfileUrl(gaiaUrlBase, ownerAddress))\n\n  // the 'indexed' URL --\n  //  this is gaia/:firstAddress/:index/profile.json\n  //  however, the index is _not_ equal to the current index.\n  //  indexes were mapped from\n  //    correct: [0, 1, 3, 5, 7, 9...]\n  //  incorrect: [0, 1, 2, 3, 4, 5...]\n\n  if (ownerIndex < 2) {\n    urls.push(`${gaiaUrlBase}${firstAddress}/${ownerIndex}/profile.json`)\n  } else if (ownerIndex % 2 === 1) {\n    const buggedIndex = 1 + Math.floor(ownerIndex / 2)\n    urls.push(`${gaiaUrlBase}${firstAddress}/${buggedIndex}/profile.json`)\n  }\n\n  return recursiveTryFetch(urls)\n}\n\nexport function signProfileForUpload(profile, keypair, api) {\n  const privateKey = keypair.key\n  const publicKey = keypair.keyID\n\n  if (profile.api && profile.api.gaiaHubConfig) {\n    profile.api.gaiaHubConfig = {\n      url_prefix: profile.api.gaiaHubConfig.url_prefix\n    }\n  }\n\n  if (api) {\n    profile = {\n      ...profile,\n      api: {\n        gaiaHubConfig: {\n          url_prefix: api.gaiaHubConfig.url_prefix\n        },\n        gaiaHubUrl: api.gaiaHubUrl\n      }\n    }\n  }\n\n  const token = signProfileToken(profile, privateKey, { publicKey })\n  const tokenRecord = wrapProfileToken(token)\n  const tokenRecords = [tokenRecord]\n  return JSON.stringify(tokenRecords, null, 2)\n}\n\nexport const DEFAULT_PROFILE = {\n  '@type': 'Person',\n  '@context': 'http://schema.org'\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst sessionStore_1 = require(\"blockstack/lib/auth/sessionStore\");\nconst bip39 = tslib_1.__importStar(require(\"bip39\"));\nconst _utils_1 = require(\"@utils\");\nconst crypto = tslib_1.__importStar(require(\"crypto\"));\nconst blockstack = tslib_1.__importStar(require(\"blockstack\"));\nconst radiks_1 = require(\"radiks\");\nconst bitcoinjs = require('bitcoinjs-lib');\nrequire(\"localstorage-polyfill\");\nexports.initWallet = () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {\n    let action = 'none';\n    const STRENGTH = 128;\n    let backupPhraseCache = localStorage.getItem('backupPhrase');\n    let backupPhrase;\n    if (backupPhraseCache) {\n        backupPhrase = backupPhraseCache;\n    }\n    else {\n        action = 'create';\n        backupPhrase = bip39.generateMnemonic(STRENGTH, crypto.randomBytes);\n        yield localStorage.setItem('backupPhrase', backupPhrase);\n    }\n    let keychain = yield initWalletFromSeed(backupPhrase);\n    return keychain;\n});\nfunction initWalletFromSeed(backupPhrase) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        let masterKeychain = null;\n        let action = 'none';\n        const seedBuffer = yield bip39.mnemonicToSeed(backupPhrase);\n        masterKeychain = yield bitcoinjs.HDNode.fromSeedBuffer(seedBuffer);\n        let keychain = {\n            backupPhrase: backupPhrase,\n            masterKeychain: masterKeychain,\n            action: action\n        };\n        return keychain;\n    });\n}\nexports.initWalletFromSeed = initWalletFromSeed;\nfunction makeUserSession(appPrivateKey, appPublicKey, username, profileJSON = null, scopes = ['store_write', 'publish_data'], appUrl = 'goodtimesx.com', hubUrl = 'https://hub.blockstack.org') {\n    const appConfig = new blockstack.AppConfig(scopes, appUrl);\n    const userData = {\n        username: username,\n        decentralizedID: 'did:btc-addr:' + appPublicKey,\n        appPrivateKey: appPrivateKey,\n        authResponseToken: '',\n        hubUrl: hubUrl,\n        identityAddress: appPublicKey,\n        profile: profileJSON,\n    };\n    const dataStore = new sessionStore_1.InstanceDataStore({\n        appPrivateKey: appPrivateKey,\n        hubUrl: hubUrl,\n        userData: userData\n    });\n    const userSession = new blockstack.UserSession({\n        appConfig: appConfig,\n        sessionStore: dataStore\n    });\n    return userSession;\n}\nexports.makeUserSession = makeUserSession;\nfunction makeProfileJSON(profile, keypair, api) {\n    let profileJSON = _utils_1.signProfileForUpload(profile, keypair, api);\n    return profileJSON;\n}\nexports.makeProfileJSON = makeProfileJSON;\nexports.saveProfileJSON = (userSession, profileJSON) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {\n    let resp = yield userSession.putFile('profile.json', JSON.stringify(profileJSON), { encrypt: false, contentType: 'application/json' });\n    return resp;\n});\nfunction configureRadiks(userSession) {\n    radiks_1.configure({\n        apiServer: process.env.RADIKS_API_SERVER,\n        userSession: userSession\n    });\n}\nexports.configureRadiks = configureRadiks;\nfunction rando() {\n    return (Math.floor(Math.random() * 100000) + 100000).toString().substring(1);\n}\nexports.rando = rando;\nexports.createBlockchainIdentity = (keychain, username = \"good\" + rando() + '.id.blockstack', avatarUrl = 'https://gaia.blockstack.org/hub/17xxYBCvxwrwKtAna4bubsxGCMCcVNAgyw/avatar-0', identitiesToGenerate = 2) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {\n    const { identityKeypairs } = _utils_1.getBlockchainIdentities(keychain.masterKeychain, identitiesToGenerate);\n    let browserPublicKey = identityKeypairs[0].address;\n    let browserPrivateKey = identityKeypairs[0].key;\n    let browserKeyID = identityKeypairs[0].keyID;\n    let profile = makeNewProfile(browserPrivateKey, browserPublicKey, avatarUrl, username);\n    let userSession = makeUserSession(browserPrivateKey, browserPublicKey, username, profile.decodedToken.payload.claim);\n    let profileResp = exports.saveProfileJSON(userSession, [profile]);\n    let appPublicKey = identityKeypairs[1].address;\n    let appPrivateKey = identityKeypairs[1].key;\n    return {\n        appPublicKey: appPublicKey,\n        appPrivateKey: appPrivateKey,\n        identityKeypairs: identityKeypairs,\n        profileJSON: profile,\n        username: username,\n        profileResp: profileResp\n    };\n});\nfunction getPublicKeyFromPrivate(privateKey) {\n    const keyPair = bitcoinjs.ECPair.fromPrivateKey(Buffer.from(privateKey, 'hex'));\n    return keyPair.publicKey.toString('hex');\n}\nexports.getPublicKeyFromPrivate = getPublicKeyFromPrivate;\nfunction makeNewProfile(privateKey, publicKey, avatarUrl, username) {\n    let api = {\n        gaiaHubConfig: {\n            url_prefix: 'https://gaia.blockstack.org/hub/'\n        },\n        gaiaHubUrl: 'https://hub.blockstack.org'\n    };\n    let profileJSON = makeProfileJSON(_utils_1.DEFAULT_PROFILE, { key: privateKey, keyID: publicKey }, api);\n    let profile = (JSON.parse(profileJSON))[0];\n    profile.decodedToken.payload.claim.image = [{\n            '@type': 'ImageObject',\n            'contentUrl': avatarUrl,\n            'name': 'avatar'\n        }];\n    return profile;\n}\nexports.makeNewProfile = makeNewProfile;\n","export function getNumberOfVerifications(profile) {\n  let numberOfVerifications = 0\n  if (profile && profile.twitter && profile.twitter.proof && profile.twitter.proof.url) {\n    numberOfVerifications += 1\n  }\n  if (profile && profile.facebook && profile.facebook.proof && profile.facebook.proof.url) {\n    numberOfVerifications += 1\n  }\n  if (profile && profile.github && profile.github.proof && profile.github.proof.url) {\n    numberOfVerifications += 1\n  }\n  return numberOfVerifications\n}\n\n\nexport function compareProfilesByVerifications(resultA, resultB) {\n  const numVerificationsA = getNumberOfVerifications(resultA.profile)\n  const numVerificationsB = getNumberOfVerifications(resultB.profile)\n  if (numVerificationsA < numVerificationsB) {\n    return 1\n  } else if (numVerificationsA > numVerificationsB) {\n    return -1\n  } else {\n    return 0\n  }\n}\n","import { REGTEST_CORE_API_ENDPOINT }  from './browser/store/settings/default'\n\nexport function openInNewTab(url) {\n  const win = window.open(url, '_blank')\n  win.focus()\n}\n\nexport function isWindowsBuild() {\n  const isWindowsBuildCompileFlag = false\n  return isWindowsBuildCompileFlag === true\n}\n\nexport function isWebAppBuild() {\n  const isWebAppCompileFlag = ( process.env.NODE_ENV === 'production' && typeof process.env.WEBAPP !== 'undefined' )\n  return isWebAppCompileFlag\n}\n\n\n/**\n * Will determine whether or not we should try to\n *  perform \"private\" core endpoint functions --\n *  basically, attempts to read/write the core wallet.\n * Tests using the compile flags determining if its\n *  a Windows / WebApp build and using the URL --\n * if it's the standard regtest URL, then, yes, try\n *  to do the private operations, otherwise, no.\n * @private\n */\nexport function isCoreEndpointDisabled(testUrl) {\n  return (isWindowsBuild() || isWebAppBuild() ||\n    !testUrl.startsWith(REGTEST_CORE_API_ENDPOINT))\n}\n\nconst mobileWindowWidth = 768\n\nexport function isMobile() {\n  if (window.innerWidth <= mobileWindowWidth) {\n    return true\n  } else {\n    return false\n  }\n}\n","\nexport async function isCryptoInWorkerSupported() {\n    const supported = global.crypto && global.crypto.getRandomValues\n    return (!!supported).toString()\n}","import crypto from 'crypto'\nimport triplesec from 'triplesec'\nimport bip39 from 'bip39'\n\n\nconst logger = console;\nasync function denormalizeMnemonic(normalizedMnemonic) {\n  return bip39.entropyToMnemonic(normalizedMnemonic)\n}\n\nasync function decryptMnemonic(dataBuffer, password) {\n  const salt = dataBuffer.slice(0, 16)\n  const hmacSig = dataBuffer.slice(16, 48) // 32 bytes\n  const cipherText = dataBuffer.slice(48)\n  const hmacPayload = Buffer.concat([salt, cipherText])\n\n  const keysAndIV = crypto.pbkdf2Sync(password, salt, 100000, 48, 'sha512')\n  const encKey = keysAndIV.slice(0, 16)\n  const macKey = keysAndIV.slice(16, 32)\n  const iv = keysAndIV.slice(32, 48)\n\n  const decipher = crypto.createDecipheriv('aes-128-cbc', encKey, iv)\n  let plaintext = decipher.update(cipherText, '', 'hex')\n  plaintext += decipher.final('hex')\n\n  const hmac = crypto.createHmac('sha256', macKey)\n  hmac.write(hmacPayload)\n  const hmacDigest = hmac.digest()\n\n  // hash both hmacSig and hmacDigest so string comparison time\n  // is uncorrelated to the ciphertext\n  const hmacSigHash = crypto\n    .createHash('sha256')\n    .update(hmacSig)\n    .digest()\n    .toString('hex')\n\n  const hmacDigestHash = crypto\n    .createHash('sha256')\n    .update(hmacDigest)\n    .digest()\n    .toString('hex')\n\n  if (hmacSigHash !== hmacDigestHash) {\n    // not authentic\n    throw new Error('Wrong password (HMAC mismatch)')\n  }\n\n  const mnemonic = await denormalizeMnemonic(plaintext)\n  if (!bip39.validateMnemonic(mnemonic)) {\n    throw new Error('Wrong password (invalid plaintext)')\n  }\n\n  return mnemonic\n}\n\nfunction decryptLegacy(dataBuffer, password) {\n  return new Promise((resolve, reject) => {\n    triplesec.decrypt(\n      {\n        key: new Buffer(password),\n        data: dataBuffer\n      },\n      (err, plaintextBuffer) => {\n        if (!err) {\n          resolve(plaintextBuffer)\n        } else {\n          reject(err)\n        }\n      }\n    )\n  })\n}\n\nexport async function decrypt(hexEncryptedKey, password) {\n  logger.debug('Decrypting from worker!')\n  const dataBuffer = Buffer.from(hexEncryptedKey, 'hex')\n  let mnemonic\n\n  try {\n    mnemonic = await decryptMnemonic(dataBuffer, password)\n  } catch (err) {\n    logger.error('Could not decrypt.', err)\n\n    try {\n      logger.debug('Trying to decrypt with legacy function.')\n      mnemonic = await decryptLegacy(dataBuffer, password)\n    } catch (e) {\n      mnemonic = null\n      logger.error('Could not decrypt again, most likely wrong password.')\n      throw Error('Wrong Password.')\n    }\n  }\n  return mnemonic.toString()\n}\n","import * as decryptMain from './decrypt.main'\n\nexport async function decrypt(hexEncryptedKey, password) {\n    return decryptMain.decrypt(hexEncryptedKey, password)\n}","import crypto from 'crypto'\nimport bip39 from 'bip39'\n\nconst logger = console;\n\nasync function normalizeMnemonic(mnemonic) {\n  return bip39.mnemonicToEntropy(mnemonic).toString('hex')\n}\n\nasync function encryptMnemonic(mnemonic, password) {\n  // must be bip39 mnemonic\n  if (!bip39.validateMnemonic(mnemonic)) {\n    throw new Error('Not a valid bip39 nmemonic')\n  }\n\n  // normalize plaintext to fixed length byte string\n  const plaintextNormalized = Buffer.from(\n    await normalizeMnemonic(mnemonic),\n    'hex'\n  )\n\n  // AES-128-CBC with SHA256 HMAC\n  const salt = crypto.randomBytes(16)\n  const keysAndIV = crypto.pbkdf2Sync(password, salt, 100000, 48, 'sha512')\n  const encKey = keysAndIV.slice(0, 16)\n  const macKey = keysAndIV.slice(16, 32)\n  const iv = keysAndIV.slice(32, 48)\n\n  const cipher = crypto.createCipheriv('aes-128-cbc', encKey, iv)\n  let cipherText = cipher.update(plaintextNormalized, '', 'hex')\n  cipherText += cipher.final('hex')\n\n  const hmacPayload = Buffer.concat([salt, Buffer.from(cipherText, 'hex')])\n\n  const hmac = crypto.createHmac('sha256', macKey)\n  hmac.write(hmacPayload)\n  const hmacDigest = hmac.digest()\n\n  return Buffer.concat([salt, hmacDigest, Buffer.from(cipherText, 'hex')])\n}\n\nexport async function encrypt(mnemonic, password) {\n  logger.debug('Encrypting from worker', mnemonic, password)\n  const encryptedBuffer = await encryptMnemonic(mnemonic, password)\n  return encryptedBuffer.toString('hex')\n}\n","import * as encryptMain from './encrypt.main'\n\nexport async function encrypt(mnemonic, password) {\n    return encryptMain.encrypt(mnemonic, password)\n}","import { Person } from 'blockstack'\nimport { getProfileFromTokens } from './profile-utils'\nimport { parseZoneFile } from 'zone-file'\n\n\nconst logger = console;\n\nexport function getTokenFileUrlFromZoneFile(zoneFileJson) {\n  if (!zoneFileJson.hasOwnProperty('uri')) {\n    return null\n  }\n  if (!Array.isArray(zoneFileJson.uri)) {\n    return null\n  }\n  if (zoneFileJson.uri.length < 1) {\n    return null\n  }\n  const firstUriRecord = zoneFileJson.uri[0]\n\n  if (!firstUriRecord.hasOwnProperty('target')) {\n    return null\n  }\n  let tokenFileUrl = firstUriRecord.target\n\n  if (tokenFileUrl.startsWith('https')) {\n    // pass\n  } else if (tokenFileUrl.startsWith('http')) {\n    // pass\n  } else {\n    tokenFileUrl = `https://${tokenFileUrl}`\n  }\n\n  return tokenFileUrl\n}\n\nexport function resolveZoneFileToProfile(zoneFile, publicKeyOrAddress) {\n  return new Promise((resolve, reject) => {\n    let zoneFileJson = null\n    try {\n      zoneFileJson = parseZoneFile(zoneFile)\n      if (!zoneFileJson.hasOwnProperty('$origin')) {\n        zoneFileJson = null\n      }\n    } catch (e) {\n      reject(e)\n    }\n\n    let tokenFileUrl = null\n    if (zoneFileJson && Object.keys(zoneFileJson).length > 0) {\n      tokenFileUrl = getTokenFileUrlFromZoneFile(zoneFileJson)\n    } else {\n      let profile = null\n      try {\n        profile = JSON.parse(zoneFile)\n        profile = Person.fromLegacyFormat(profile).profile()\n      } catch (error) {\n        reject(error)\n      }\n      resolve(profile)\n      return\n    }\n\n    if (tokenFileUrl) {\n      fetch(tokenFileUrl)\n        .catch(error => {\n          logger.error(\n            'resolveZoneFileToProfile: error fetching token file without CORS proxy',\n            error\n          )\n          return proxyFetch(tokenFileUrl)\n        })\n        .then(response => response.text())\n        .then(responseText => JSON.parse(responseText))\n        .then(responseJson => {\n          const tokenRecords = responseJson\n          const profile = getProfileFromTokens(tokenRecords, publicKeyOrAddress)\n\n          resolve(profile)\n          return\n        })\n        .catch(error => {\n          logger.error(`resolveZoneFileToProfile: error fetching token file ${tokenFileUrl}`, error)\n          reject(error)\n        })\n    } else {\n      logger.warn('Token file url not found. Resolving to blank profile.')\n      resolve({})\n      return\n    }\n  })\n}\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/uBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAEA;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjdA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3MA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AAIA;;;;;;;;;;;;;AChDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7HA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzCA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9FA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7CA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A","sourceRoot":""}